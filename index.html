<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LunX Studio - Ultimate Edition</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <style>
        :root {
            --primary: #D32F2F;
            --primary-dark: #B71C1C;
            --accent: #1976D2;
            --text: #333;
            --panel-width: 260px;
        }
        
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; touch-action: none; outline: none; }
        body { margin: 0; overflow: hidden; background: #222; height: 100vh; display: flex; flex-direction: column; color: var(--text); }

        /* --- UI HEADER & RIBBON --- */
        #header { height: 40px; background: var(--primary); display: flex; align-items: center; padding: 0 15px; color: white; justify-content: space-between; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 100; }
        .logo { font-weight: 800; letter-spacing: 1px; font-size: 18px; }
        .logo span { background: white; color: var(--primary); padding: 1px 6px; border-radius: 4px; margin-right: 5px; }
        
        .toolbar-btn { background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 15px; border-radius: 4px; cursor: pointer; font-weight: bold; transition: 0.2s; font-size: 12px; margin-left: 10px; }
        .toolbar-btn:hover { background: rgba(255,255,255,0.3); }
        .play-btn { background: #4CAF50; color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .stop-btn { background: #F44336; display: none; }

        #ribbon { height: 90px; background: #F5F5F5; border-bottom: 1px solid #DDD; display: flex; overflow-x: auto; padding: 5px 10px; align-items: center; transition: height 0.3s; }
        .tool-group { display: flex; height: 100%; padding-right: 15px; margin-right: 15px; border-right: 1px solid #E0E0E0; gap: 5px; align-items: center; }
        
        .tool { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 60px; height: 70px; cursor: pointer; border-radius: 4px; transition: 0.1s; color: #444; font-size: 11px; text-align: center; }
        .tool:hover { background: white; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .tool.active { background: #FFEBEE; color: var(--primary); border: 1px solid var(--primary-dark); }
        .tool i { font-size: 24px; margin-bottom: 5px; display: block; }

        /* --- MAIN WORKSPACE --- */
        #workspace { flex: 1; display: flex; position: relative; overflow: hidden; }
        
        .panel { width: var(--panel-width); background: white; display: flex; flex-direction: column; border-left: 1px solid #DDD; border-right: 1px solid #DDD; transition: width 0.3s; z-index: 50; }
        .panel-head { background: #EEE; padding: 8px 10px; font-weight: bold; font-size: 12px; border-bottom: 1px solid #CCC; display: flex; justify-content: space-between; }
        .panel-body { flex: 1; overflow-y: auto; padding: 0; font-size: 12px; }
        .panel.closed { width: 0; border: none; }

        /* EXPLORER & PROPERTIES */
        .tree-node { padding: 4px 10px; cursor: pointer; display: flex; align-items: center; gap: 5px; border-bottom: 1px solid #FAFAFA; }
        .tree-node:hover { background: #F0F0F0; }
        .tree-node.selected { background: #E3F2FD; color: #1565C0; }
        
        .prop-row { display: flex; align-items: center; border-bottom: 1px solid #EEE; padding: 4px 8px; }
        .prop-label { width: 40%; color: #666; }
        .prop-input { width: 60%; border: 1px solid transparent; background: transparent; padding: 2px; }
        .prop-input:focus { background: white; border-color: var(--primary); }

        /* VIEWPORT */
        #viewport { flex: 1; position: relative; background: #B3E5FC; overflow: hidden; }
        
        /* GAME UI (JOYSTICK etc.) */
        #game-hud { position: absolute; inset: 0; pointer-events: none; display: none; z-index: 500; }
        
        #joystick-area { position: absolute; bottom: 40px; left: 40px; width: 140px; height: 140px; background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; pointer-events: auto; backdrop-filter: blur(2px); }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background: rgba(255,255,255,0.9); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 4px 10px rgba(0,0,0,0.3); cursor: pointer; }
        
        #jump-btn { position: absolute; bottom: 50px; right: 40px; width: 90px; height: 90px; background: rgba(211, 47, 47, 0.8); border: 4px solid rgba(255,255,255,0.8); border-radius: 50%; pointer-events: auto; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 24px; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3); transition: transform 0.1s; }
        #jump-btn:active { transform: scale(0.9); background: rgba(211, 47, 47, 1); }

        /* LUNAIX AI WINDOW */
        #lunaix-panel { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 500px; height: 260px; background: white; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.4); display: none; flex-direction: column; z-index: 1000; overflow: hidden; animation: slideUp 0.3s ease; }
        @keyframes slideUp { from { transform: translate(-50%, 100%); } to { transform: translate(-50%, 0); } }
        
        #lunaix-header { background: linear-gradient(135deg, #2c3e50, #000); color: white; padding: 10px 15px; font-weight: bold; display: flex; justify-content: space-between; align-items: center; }
        #lunaix-chat { flex: 1; background: #F8F9FA; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }
        .msg { padding: 8px 12px; border-radius: 8px; max-width: 80%; font-size: 13px; line-height: 1.4; }
        .msg.bot { background: white; border: 1px solid #E0E0E0; align-self: flex-start; color: #333; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .msg.user { background: var(--primary); color: white; align-self: flex-end; }
        #lunaix-input-area { padding: 10px; background: white; border-top: 1px solid #EEE; display: flex; gap: 10px; }
        #lunaix-input { flex: 1; padding: 8px; border: 1px solid #DDD; border-radius: 6px; }
    </style>
</head>
<body onload="Engine.init()">

    <div id="header">
        <div class="logo"><span>LunX</span> STUDIO</div>
        <div>
            <button class="toolbar-btn play-btn" id="btn-play" onclick="Game.start()">‚ñ∂ OYNA</button>
            <button class="toolbar-btn stop-btn" id="btn-stop" onclick="Game.stop()">‚èπ DURDUR</button>
        </div>
    </div>

    <div id="ribbon">
        <div class="tool-group">
            <div class="tool active" onclick="Editor.setMode('select', this)"><i>üëÜ</i>Se√ß</div>
            <div class="tool" onclick="Editor.setMode('translate', this)"><i>‚ÜîÔ∏è</i>Ta≈üƒ±</div>
            <div class="tool" onclick="Editor.setMode('scale', this)"><i>‚§°</i>Boyut</div>
            <div class="tool" onclick="Editor.setMode('rotate', this)"><i>üîÑ</i>D√∂nd√ºr</div>
        </div>
        <div class="tool-group">
            <div class="tool" onclick="World.addPart('box')"><i>üì¶</i>K√ºp</div>
            <div class="tool" onclick="World.addPart('sphere')"><i>‚ö™</i>K√ºre</div>
            <div class="tool" onclick="World.addPart('cylinder')"><i>üõ¢Ô∏è</i>Silindir</div>
            <div class="tool" onclick="World.addPart('plane')"><i>‚¨ú</i>Zemin</div>
        </div>
        <div class="tool-group">
            <div class="tool" onclick="Editor.setMode('sculpt', this)"><i>‚õ∞Ô∏è</i>Sculpt</div>
            <div class="tool" style="color:#D32F2F" onclick="UI.toggleAI()"><i>ü§ñ</i>LunAIX</div>
            <div class="tool" onclick="World.clearAll()"><i>üóëÔ∏è</i>Temizle</div>
        </div>
        <div class="tool-group">
            <div class="tool" onclick="UI.togglePanel('explorer')"><i>üìÇ</i>Explorer</div>
            <div class="tool" onclick="UI.togglePanel('properties')"><i>‚öôÔ∏è</i>√ñzellik</div>
        </div>
    </div>

    <div id="workspace">
        <div id="panel-explorer" class="panel closed">
            <div class="panel-head">Explorer <span onclick="UI.togglePanel('explorer')" style="cursor:pointer">√ó</span></div>
            <div class="panel-body" id="explorer-list">
                <div class="tree-node">üìÇ Workspace</div>
            </div>
        </div>

        <div id="viewport">
            <div id="game-hud">
                <div id="joystick-area"><div id="joystick-knob"></div></div>
                <div id="jump-btn">‚¨Ü</div>
            </div>
        </div>

        <div id="panel-properties" class="panel">
            <div class="panel-head">√ñzellikler <span onclick="UI.togglePanel('properties')" style="cursor:pointer">√ó</span></div>
            <div class="panel-body" id="prop-list">
                <div style="padding:20px; text-align:center; color:#999;">Nesne se√ßili deƒüil</div>
            </div>
        </div>
    </div>

    <div id="lunaix-panel">
        <div id="lunaix-header">LunAIX Mimar <span onclick="UI.toggleAI()" style="cursor:pointer; font-size:18px;">√ó</span></div>
        <div id="lunaix-chat">
            <div class="msg bot">Merhaba! Ben LunAIX. Ne in≈üa etmek istersin? (√ñrn: "B√ºy√ºk bir kale", "Orman", "Labirent", "G√∂kdelenler")</div>
        </div>
        <div id="lunaix-input-area">
            <input type="text" id="lunaix-input" placeholder="Buraya yaz..." onkeydown="if(event.key==='Enter') AI.process()">
            <button onclick="AI.process()" style="background:var(--primary); color:white; border:none; padding:0 15px; border-radius:6px; cursor:pointer;">ƒ∞n≈üa Et</button>
        </div>
    </div>

    <script>
        /* ==========================================
           ENGINE CORE (THREE.JS + CANNON.JS)
           ========================================== */
        const Engine = {
            scene: null, camera: null, renderer: null,
            world: null, // Physics World
            clock: new THREE.Clock(),
            objects: [], // Visual Meshes
            physicsBodies: [], // Physics Bodies
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector2(),
            
            init: () => {
                // 1. Setup Three.js
                const vp = document.getElementById('viewport');
                Engine.scene = new THREE.Scene();
                Engine.scene.background = new THREE.Color(0x87CEEB); // Sky blue
                Engine.scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

                Engine.camera = new THREE.PerspectiveCamera(70, vp.clientWidth / vp.clientHeight, 0.1, 1000);
                Engine.camera.position.set(10, 10, 10);

                Engine.renderer = new THREE.WebGLRenderer({ antialias: true });
                Engine.renderer.setSize(vp.clientWidth, vp.clientHeight);
                Engine.renderer.shadowMap.enabled = true;
                vp.appendChild(Engine.renderer.domElement);

                // 2. Setup Cannon.js (Physics)
                Engine.world = new CANNON.World();
                Engine.world.gravity.set(0, -20, 0); // Earth gravity
                Engine.world.broadphase = new CANNON.NaiveBroadphase();
                Engine.world.defaultContactMaterial.friction = 0.3;

                // 3. Lighting
                const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                Engine.scene.add(hemiLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(50, 100, 50);
                dirLight.castShadow = true;
                dirLight.shadow.camera.left = -50; dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50; dirLight.shadow.camera.bottom = -50;
                dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
                Engine.scene.add(dirLight);

                // 4. Controls & Tools
                Editor.init();
                World.createBaseplate();
                Input.init();

                // 5. Loop
                window.addEventListener('resize', Engine.resize);
                vp.addEventListener('pointerdown', Editor.onMouseDown);
                Engine.loop();
            },

            resize: () => {
                const vp = document.getElementById('viewport');
                Engine.camera.aspect = vp.clientWidth / vp.clientHeight;
                Engine.camera.updateProjectionMatrix();
                Engine.renderer.setSize(vp.clientWidth, vp.clientHeight);
            },

            loop: () => {
                requestAnimationFrame(Engine.loop);
                const dt = Math.min(Engine.clock.getDelta(), 0.1);

                // Physics Step
                Engine.world.step(1/60, dt, 3);

                // Sync Visuals with Physics
                for(let i=0; i<Engine.objects.length; i++) {
                    const mesh = Engine.objects[i];
                    const body = mesh.userData.body;
                    if(body && !mesh.userData.dragging) { // Don't sync if dragging in editor
                        mesh.position.copy(body.position);
                        mesh.quaternion.copy(body.quaternion);
                    }
                }

                // Game Logic
                if(Game.active) Game.update(dt);
                else Editor.update();

                Engine.renderer.render(Engine.scene, Engine.camera);
            }
        };

        /* ==========================================
           WORLD & OBJECT MANAGEMENT
           ========================================== */
        const World = {
            materials: {
                default: new THREE.MeshStandardMaterial({ color: 0x9E9E9E }),
                highlight: new THREE.MeshStandardMaterial({ color: 0x64B5F6, emissive: 0x222222 })
            },

            createBaseplate: () => {
                // Visual
                const geo = new THREE.BoxGeometry(200, 2, 200);
                const mat = new THREE.MeshStandardMaterial({ color: 0x4CAF50 }); // Grass green
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.y = -1;
                mesh.receiveShadow = true;
                mesh.name = "Baseplate";
                Engine.scene.add(mesh);

                // Physics
                const shape = new CANNON.Box(new CANNON.Vec3(100, 1, 100));
                const body = new CANNON.Body({ mass: 0, shape: shape });
                body.position.copy(mesh.position);
                Engine.world.addBody(body);

                mesh.userData = { body: body, locked: true };
                Engine.objects.push(mesh);

                // Grid
                const grid = new THREE.GridHelper(200, 50, 0x000000, 0x000000);
                grid.material.opacity = 0.1;
                grid.material.transparent = true;
                grid.position.y = 0.05;
                Engine.scene.add(grid);
            },

            addPart: (type, config = {}) => {
                let geo, shape;
                const size = config.size || {x:4, y:4, z:4};
                const color = config.color || Math.random() * 0xffffff;
                
                if (type === 'sphere') {
                    geo = new THREE.SphereGeometry(size.x/2, 32, 32);
                    shape = new CANNON.Sphere(size.x/2);
                } else if (type === 'cylinder') {
                    geo = new THREE.CylinderGeometry(size.x/2, size.x/2, size.y, 32);
                    shape = new CANNON.Cylinder(size.x/2, size.x/2, size.y, 12);
                    // Cannon cylinders align to Z, Three aligns to Y. Need rotation fix later if strict.
                } else if (type === 'plane') {
                    geo = new THREE.BoxGeometry(size.x, 0.5, size.z);
                    shape = new CANNON.Box(new CANNON.Vec3(size.x/2, 0.25, size.z/2));
                } else { // Box
                    geo = new THREE.BoxGeometry(size.x, size.y, size.z);
                    shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
                }

                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
                const mesh = new THREE.Mesh(geo, mat);
                
                const pos = config.pos || new THREE.Vector3(0, 10, 0);
                mesh.position.copy(pos);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.name = config.name || type.charAt(0).toUpperCase() + type.slice(1);

                const mass = config.anchored ? 0 : (size.x * size.y * size.z);
                const body = new CANNON.Body({ mass: mass, shape: shape });
                body.position.copy(pos);
                
                Engine.scene.add(mesh);
                Engine.world.addBody(body);
                
                mesh.userData = { body, type, anchored: !!config.anchored };
                Engine.objects.push(mesh);
                UI.addExplorerItem(mesh);

                return mesh;
            },

            clearAll: () => {
                [...Engine.objects].forEach(obj => {
                    if(obj.name !== "Baseplate" && !obj.userData.isPlayer) {
                        Engine.scene.remove(obj);
                        Engine.world.removeBody(obj.userData.body);
                    }
                });
                Engine.objects = Engine.objects.filter(o => o.name === "Baseplate" || o.userData.isPlayer);
                document.getElementById('explorer-list').innerHTML = '<div class="tree-node">üìÇ Workspace</div>';
            }
        };

        /* ==========================================
           EDITOR & SCULPT TOOLS
           ========================================== */
        const Editor = {
            controls: null, transformer: null,
            selected: null, mode: 'select',
            
            init: () => {
                Editor.controls = new THREE.OrbitControls(Engine.camera, Engine.renderer.domElement);
                Editor.controls.enableDamping = true;

                Editor.transformer = new THREE.TransformControls(Engine.camera, Engine.renderer.domElement);
                Editor.transformer.addEventListener('dragging-changed', e => Editor.controls.enabled = !e.value);
                Editor.transformer.addEventListener('change', () => Editor.syncPhysics()); // Update physics when dragging
                Engine.scene.add(Editor.transformer);
            },

            update: () => {
                Editor.controls.update();
            },

            setMode: (mode, btnElement) => {
                Editor.mode = mode;
                // UI Update
                document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
                if(btnElement) btnElement.classList.add('active');

                if (mode === 'sculpt' || mode === 'select') {
                    Editor.transformer.detach();
                } else if (Editor.selected) {
                    Editor.transformer.setMode(mode);
                    Editor.transformer.attach(Editor.selected);
                }
            },

            onMouseDown: (e) => {
                if (Game.active) return; // Don't select in game mode

                const rect = document.getElementById('viewport').getBoundingClientRect();
                Engine.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                Engine.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                Engine.raycaster.setFromCamera(Engine.mouse, Engine.camera);
                const intersects = Engine.raycaster.intersectObjects(Engine.objects);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    
                    // SCULPT MODE
                    if (Editor.mode === 'sculpt') {
                        World.addPart('sphere', {
                            pos: hit.point,
                            size: {x:2, y:2, z:2},
                            color: 0x8D6E63,
                            anchored: true,
                            name: 'TerrainNode'
                        });
                        return;
                    }

                    // SELECT MODE
                    if (hit.object.name !== "Baseplate") {
                        Editor.select(hit.object);
                    } else {
                        Editor.select(null);
                    }
                } else {
                    Editor.select(null);
                }
            },

            select: (obj) => {
                Editor.selected = obj;
                if (obj) {
                    if(Editor.mode !== 'sculpt' && Editor.mode !== 'select') {
                        Editor.transformer.attach(obj);
                    }
                    UI.updateProperties(obj);
                } else {
                    Editor.transformer.detach();
                    document.getElementById('prop-list').innerHTML = '<div style="padding:20px; text-align:center; color:#999;">Se√ßim Yok</div>';
                }
            },

            syncPhysics: () => {
                if (Editor.selected && Editor.selected.userData.body) {
                    const mesh = Editor.selected;
                    const body = mesh.userData.body;
                    body.position.copy(mesh.position);
                    body.quaternion.copy(mesh.quaternion);
                    body.velocity.set(0,0,0);
                    body.angularVelocity.set(0,0,0);
                }
            }
        };

        /* ==========================================
           GAMEPLAY (CHARACTER & PHYSICS)
           ========================================== */
        const Game = {
            active: false,
            player: { mesh: null, body: null },
            input: { x: 0, y: 0, jump: false },
            
            start: () => {
                Game.active = true;
                document.getElementById('btn-play').style.display = 'none';
                document.getElementById('btn-stop').style.display = 'inline-block';
                document.getElementById('ribbon').style.height = '0';
                document.getElementById('game-hud').style.display = 'block';
                
                Editor.select(null); // Deselect everything
                Game.spawnPlayer();
            },

            stop: () => {
                Game.active = false;
                document.getElementById('btn-play').style.display = 'inline-block';
                document.getElementById('btn-stop').style.display = 'none';
                document.getElementById('ribbon').style.height = '90px';
                document.getElementById('game-hud').style.display = 'none';

                // Cleanup player
                if (Game.player.mesh) {
                    Engine.scene.remove(Game.player.mesh);
                    Engine.world.removeBody(Game.player.body);
                    Engine.objects = Engine.objects.filter(o => !o.userData.isPlayer);
                }
                
                // Reset Camera
                Engine.camera.position.set(10, 10, 10);
                Engine.camera.lookAt(0, 0, 0);
                Editor.controls.enabled = true;
            },

            spawnPlayer: () => {
                // R6 Style Character Group
                const group = new THREE.Group();
                
                // Materials
                const mSkin = new THREE.MeshStandardMaterial({color: 0xFFD54F}); // Yellow
                const mTorso = new THREE.MeshStandardMaterial({color: 0x1976D2}); // Blue
                const mLegs = new THREE.MeshStandardMaterial({color: 0x4CAF50}); // Green

                // Parts
                const head = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), mSkin); head.position.y = 1.5;
                const torso = new THREE.Mesh(new THREE.BoxGeometry(2,2,1), mTorso); 
                const lArm = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), mSkin); lArm.position.set(-1.5,0,0);
                const rArm = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), mSkin); rArm.position.set(1.5,0,0);
                const lLeg = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), mLegs); lLeg.position.set(-0.5,-2,0);
                const rLeg = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), mLegs); rLeg.position.set(0.5,-2,0);

                group.add(head, torso, lArm, rArm, lLeg, rLeg);
                group.position.set(0, 5, 0);
                group.castShadow = true;
                
                Engine.scene.add(group);

                // Physics Body (Capsule approximation with Cylinder/Sphere)
                // We use a box for simplicity and stability in this demo
                const shape = new CANNON.Box(new CANNON.Vec3(1, 2.5, 0.5)); 
                const body = new CANNON.Body({
                    mass: 50, // Player mass
                    fixedRotation: true,
                    position: new CANNON.Vec3(0, 10, 0),
                    linearDamping: 0.9 // Stops sliding
                });
                body.addShape(shape);
                Engine.world.addBody(body);

                group.userData = { body: body, isPlayer: true };
                Game.player = { mesh: group, body: body };
                Engine.objects.push(group);
            },

            update: (dt) => {
                if (!Game.player.body) return;

                const body = Game.player.body;
                const speed = 15;
                const jumpForce = 15;

                // Camera Follow Logic
                const camOffset = new THREE.Vector3(0, 5, 12); // Behind and up
                const playerPos = new THREE.Vector3(body.position.x, body.position.y, body.position.z);
                
                // Smooth camera follow
                Engine.camera.position.lerp(playerPos.clone().add(camOffset), 0.1);
                Engine.camera.lookAt(playerPos.clone().add(new THREE.Vector3(0, 2, 0)));

                // Movement Logic (Relative to Camera but locked Y)
                // Simple implementation: Direct X/Z movement based on input
                // For a true TPS, we would rotate input vector by camera angle.
                // Here we keep it simple: Joystick Up = -Z, Right = +X
                
                const velocity = new THREE.Vector3(Game.input.x * speed, body.velocity.y, Game.input.y * -speed);
                
                // Update Body Velocity
                body.velocity.x = velocity.x;
                body.velocity.z = velocity.z;

                // Rotate Character to face movement direction
                if (Math.abs(Game.input.x) > 0.1 || Math.abs(Game.input.y) > 0.1) {
                    const angle = Math.atan2(velocity.x, velocity.z);
                    Game.player.mesh.rotation.y = angle;
                }

                // Jump
                if (Game.input.jump) {
                    // Simple ground check (raycast downwards would be better but checking height works for demo)
                    // Allowing jump if not falling too fast
                    if(Math.abs(body.velocity.y) < 1) {
                        body.velocity.y = jumpForce;
                    }
                    Game.input.jump = false;
                }
            }
        };

        /* ==========================================
           INPUT MANAGEMENT (JOYSTICK & KEYS)
           ========================================== */
        const Input = {
            init: () => {
                // KEYBOARD
                window.addEventListener('keydown', (e) => {
                    if(e.key === 'w') Game.input.y = 1;
                    if(e.key === 's') Game.input.y = -1;
                    if(e.key === 'a') Game.input.x = -1;
                    if(e.key === 'd') Game.input.x = 1;
                    if(e.code === 'Space') Game.input.jump = true;
                });
                window.addEventListener('keyup', (e) => {
                    if(['w','s'].includes(e.key)) Game.input.y = 0;
                    if(['a','d'].includes(e.key)) Game.input.x = 0;
                });

                // JOYSTICK (Touch & Mouse)
                const zone = document.getElementById('joystick-area');
                const knob = document.getElementById('joystick-knob');
                let dragging = false;
                let startX, startY;

                const startDrag = (e) => {
                    dragging = true;
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const rect = zone.getBoundingClientRect();
                    startX = rect.left + rect.width / 2;
                    startY = rect.top + rect.height / 2;
                    knob.style.transition = 'none';
                };

                const moveDrag = (e) => {
                    if (!dragging) return;
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    let dx = clientX - startX;
                    let dy = clientY - startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const maxDist = 40;
                    
                    if (dist > maxDist) {
                        dx = (dx / dist) * maxDist;
                        dy = (dy / dist) * maxDist;
                    }

                    knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    
                    // Update Game Input (-1 to 1)
                    Game.input.x = dx / maxDist;
                    Game.input.y = -(dy / maxDist); // Invert Y because screen Y is down, 3D Y is usually handled as Z
                };

                const endDrag = () => {
                    dragging = false;
                    knob.style.transition = '0.2s';
                    knob.style.transform = 'translate(-50%, -50%)';
                    Game.input.x = 0;
                    Game.input.y = 0;
                };

                zone.addEventListener('mousedown', startDrag);
                window.addEventListener('mousemove', moveDrag);
                window.addEventListener('mouseup', endDrag);
                
                zone.addEventListener('touchstart', startDrag);
                window.addEventListener('touchmove', moveDrag);
                window.addEventListener('touchend', endDrag);

                // JUMP BUTTON
                const jBtn = document.getElementById('jump-btn');
                jBtn.addEventListener('pointerdown', () => Game.input.jump = true);
            }
        };

        /* ==========================================
           LUNAIX ARTIFICIAL INTELLIGENCE
           ========================================== */
        const AI = {
            log: (text, type) => {
                const chat = document.getElementById('lunaix-chat');
                chat.innerHTML += `<div class="msg ${type}">${text}</div>`;
                chat.scrollTop = chat.scrollHeight;
            },

            process: () => {
                const inp = document.getElementById('lunaix-input');
                const txt = inp.value.trim().toLowerCase();
                if(!txt) return;

                AI.log(inp.value, 'user');
                inp.value = '';

                AI.log("Tasarƒ±m analiz ediliyor... ƒ∞nternet veritabanƒ± sim√ºle ediliyor...", 'bot');

                setTimeout(() => {
                    AI.build(txt);
                }, 800);
            },

            // Procedural Generation Engine (Simulates "Internet Knowledge")
            build: (query) => {
                const origin = new THREE.Vector3(Math.random()*40 - 20, 0, Math.random()*40 - 20);
                let built = false;

                // 1. CASTLE / KALE
                if (query.includes('kale') || query.includes('castle')) {
                    AI.log("Orta√ßaƒü Kalesi in≈üa ediliyor...", 'bot');
                    // 4 Kule
                    [[0,0], [20,0], [0,20], [20,20]].forEach(c => {
                        World.addPart('cylinder', {pos: origin.clone().add(new THREE.Vector3(c[0], 5, c[1])), size:{x:4, y:10}, color:0x757575, anchored:true});
                        World.addPart('cylinder', {pos: origin.clone().add(new THREE.Vector3(c[0], 11, c[1])), size:{x:5, y:2}, color:0x424242, anchored:true});
                    });
                    // Duvarlar
                    World.addPart('box', {pos: origin.clone().add(new THREE.Vector3(10, 4, 0)), size:{x:16, y:8, z:2}, color:0x616161, anchored:true});
                    World.addPart('box', {pos: origin.clone().add(new THREE.Vector3(10, 4, 20)), size:{x:16, y:8, z:2}, color:0x616161, anchored:true});
                    World.addPart('box', {pos: origin.clone().add(new THREE.Vector3(0, 4, 10)), size:{x:2, y:8, z:16}, color:0x616161, anchored:true});
                    World.addPart('box', {pos: origin.clone().add(new THREE.Vector3(20, 4, 10)), size:{x:2, y:8, z:16}, color:0x616161, anchored:true});
                    built = true;
                }

                // 2. CITY / ≈ûEHƒ∞R / G√ñKDELEN
                else if (query.includes('≈üehir') || query.includes('city') || query.includes('g√∂kdelen')) {
                    AI.log("Modern ≈ûehir sil√ºeti olu≈üturuluyor (50+ Blok)...", 'bot');
                    for(let i=0; i<50; i++) {
                        const x = (Math.random() * 100) - 50;
                        const z = (Math.random() * 100) - 50;
                        const h = 10 + Math.random() * 30;
                        const w = 4 + Math.random() * 6;
                        const col = Math.random() > 0.5 ? 0x263238 : 0x37474F;
                        World.addPart('box', {
                            pos: new THREE.Vector3(x, h/2, z),
                            size: {x:w, y:h, z:w},
                            color: col,
                            anchored: true,
                            name: 'Building_' + i
                        });
                        // Windows texture simulation
                        if(Math.random()>0.5) {
                            World.addPart('box', {pos:new THREE.Vector3(x, h, z), size:{x:w-1, y:0.5, z:w-1}, color:0xFFFF00, anchored:true});
                        }
                    }
                    built = true;
                }

                // 3. FOREST / ORMAN
                else if (query.includes('orman') || query.includes('aƒüa√ß') || query.includes('forest')) {
                    AI.log("Biyolojik √ße≈üitlilik olu≈üturuluyor...", 'bot');
                    for(let i=0; i<30; i++) {
                        const x = (Math.random() * 80) - 40;
                        const z = (Math.random() * 80) - 40;
                        // G√∂vde
                        World.addPart('cylinder', {pos: new THREE.Vector3(x, 2, z), size:{x:1, y:4}, color:0x5D4037, anchored:true, name:'Trunk'});
                        // Yapraklar
                        World.addPart('sphere', {pos: new THREE.Vector3(x, 5, z), size:{x:4}, color:0x2E7D32, anchored:true, name:'Leaves'});
                    }
                    built = true;
                }
                
                // 4. PYRAMID
                else if (query.includes('piramit')) {
                    AI.log("Geometrik Piramit hesaplanƒ±yor...", 'bot');
                    let size = 30;
                    let y = 1;
                    while(size > 0) {
                        World.addPart('box', {pos: origin.clone().add(new THREE.Vector3(0, y, 0)), size:{x:size, y:2, z:size}, color:0xFBC02D, anchored:true});
                        size -= 4;
                        y += 2;
                    }
                    built = true;
                }

                else {
                    AI.log("Bunu tam anlayamadƒ±m ama rastgele bir yapƒ± olu≈üturuyorum.", 'bot');
                    for(let i=0; i<10; i++) {
                        World.addPart('box', {
                            pos: origin.clone().add(new THREE.Vector3(Math.random()*10, Math.random()*10, Math.random()*10)), 
                            size:{x:2,y:2,z:2}, color: Math.random()*0xffffff, anchored:false
                        });
                    }
                    built = true;
                }

                if(built) AI.log("ƒ∞n≈üaat tamamlandƒ±! ‚úîÔ∏è", 'bot');
            }
        };

        /* ==========================================
           UI & UTILS
           ========================================== */
        const UI = {
            togglePanel: (id) => {
                const el = document.getElementById('panel-'+id);
                el.classList.toggle('closed');
            },
            toggleAI: () => {
                const el = document.getElementById('lunaix-panel');
                el.style.display = el.style.display === 'flex' ? 'none' : 'flex';
            },
            addExplorerItem: (mesh) => {
                const list = document.getElementById('explorer-list');
                const div = document.createElement('div');
                div.className = 'tree-node';
                div.innerHTML = `<span>${mesh.userData.anchored ? '‚öì' : 'üì¶'}</span> ${mesh.name}`;
                div.onclick = () => Editor.select(mesh);
                list.appendChild(div);
            },
            updateProperties: (obj) => {
                const list = document.getElementById('prop-list');
                list.innerHTML = '';
                
                const props = [
                    { label: 'Ad', val: obj.name, type: 'text', change: v => obj.name = v },
                    { label: 'Poz X', val: obj.position.x.toFixed(1), type: 'text', change: null },
                    { label: 'Poz Y', val: obj.position.y.toFixed(1), type: 'text', change: null },
                    { label: 'Poz Z', val: obj.position.z.toFixed(1), type: 'text', change: null },
                    { label: 'Anchor', val: obj.userData.anchored ? 'Evet' : 'Hayƒ±r', type: 'text', change: null }
                ];

                props.forEach(p => {
                    list.innerHTML += `
                        <div class="prop-row">
                            <div class="prop-label">${p.label}</div>
                            <input class="prop-input" value="${p.val}" ${p.change ? '' : 'readonly'} onchange="/* logic */">
                        </div>
                    `;
                });
                
                list.innerHTML += `<div style="padding:10px; color:#666; font-size:10px;">* Pozisyon d√ºzenleme i√ßin ara√ßlarƒ± kullanƒ±n</div>`;
            }
        };

    </script>
</body>
</html>
