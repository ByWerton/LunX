<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LunX Studio - Advanced LunAIX Engine</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <style>
        /* CSS Kodlarƒ± (√ñncekiyle aynƒ±, sadele≈ütirildi) */
        :root {
            --primary: #d32f2f; /* Roblox Kƒ±rmƒ±zƒ±sƒ± */
            --primary-dark: #b71c1c;
            --bg-light: #f5f5f5;
            --bg-panel: #ffffff;
            --border: #e0e0e0;
            --text: #333;
            --header-h: 40px;
            --ribbon-h: 100px;
            --ui-scale: 1;
        }

        * { box-sizing: border-box; user-select: none; font-family: 'Segoe UI', sans-serif; outline: none; touch-action: none; }
        body { margin: 0; overflow: hidden; background: var(--bg-light); height: 100vh; display: flex; flex-direction: column; }
        .ui-scaled { zoom: var(--ui-scale); }

        /* Ba≈ülangƒ±√ß Ekranƒ± */
        #start-screen {
            position: fixed; inset: 0; background: linear-gradient(135deg, #d32f2f, #ffCDD2);
            z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
        }
        .template-grid { display: flex; gap: 20px; margin-top: 30px; }
        .template-card {
            background: white; color: #333; width: 150px; height: 180px; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.3s; box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        .template-card:hover { transform: translateY(-10px); }
        .t-icon { font-size: 40px; margin-bottom: 10px; }

        /* √úst Bar ve ≈ûerit */
        #top-bar { height: var(--header-h); background: var(--primary); color: white; display: flex; align-items: center; padding: 0 10px; font-size: 14px; z-index: 100; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        #x-menu-btn { width: 30px; height: 30px; background: white; color: var(--primary); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-weight: 900; cursor: pointer; margin-right: 15px; }
        .menu-item { padding: 0 15px; cursor: pointer; opacity: 0.9; height: 100%; display: flex; align-items: center; } 
        .menu-item:hover { opacity: 1; font-weight: bold; background: rgba(255,255,255,0.1); }
        .menu-item.active { background: rgba(0,0,0,0.2); font-weight: bold; }
        #ribbon { height: var(--ribbon-h); background: var(--bg-panel); border-bottom: 1px solid var(--border); padding: 5px; flex-shrink: 0; position: relative; overflow: hidden; }
        .ribbon-tab-content { display: flex; gap: 5px; height: 100%; overflow-x: auto; position: absolute; top: 0; left: 0; right: 0; padding: 5px; background: inherit; }
        .ribbon-tab-content.hidden { display: none; }
        .tool-group { display: flex; gap: 5px; padding: 0 10px; border-right: 1px solid #eee; align-items: center; }
        .r-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; min-width: 60px; height: 80px; border-radius: 5px; cursor: pointer; transition: 0.2s; color: #444; }
        .r-btn:hover { background: #ffebee; }
        .r-btn span { font-size: 24px; margin-bottom: 5px; }
        #game-controls { position: absolute; right: 10px; top: 5px; height: 90px; display: flex; gap: 5px; align-items: center; }

        /* D√ºzen ve Paneller */
        #layout { flex: 1; display: flex; position: relative; overflow: hidden; }
        #toolbox { width: 250px; background: var(--bg-panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; z-index: 20; transition: width 0.3s ease; position: relative; }
        #toolbox.closed { width: 0; border: none; overflow: hidden; }
        .panel-h { padding: 8px; background: #eee; font-weight: bold; font-size: 12px; border-bottom: 1px solid #ddd; }
        #viewport { flex: 1; position: relative; background: #87CEEB; overflow: hidden; }
        #properties { width: 280px; background: var(--bg-panel); border-left: 1px solid var(--border); display: flex; flex-direction: column; z-index: 20; }
        #explorer { height: 35%; overflow-y: auto; border-bottom: 1px solid #ddd; }
        #prop-content { flex: 1; overflow-y: auto; padding: 10px; }
        .prop-row { display: flex; align-items: center; margin-bottom: 8px; font-size: 11px; }
        .prop-lbl { width: 40%; color: #666; }
        .prop-inp { width: 60%; padding: 4px; border: 1px solid #ccc; }
        .tree-item { padding: 2px 5px; font-size: 12px; cursor: pointer; display: flex; align-items: center; }
        .tree-item:hover { background: #eee; }
        .tree-item.selected { background: #ffcdd2; border-left: 3px solid var(--primary); }

        /* HUD ve AI/Script Modallarƒ± */
        #game-overlay { position: absolute; inset: 0; pointer-events: none; display: none; z-index: 50; }
        #stop-btn-hud { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: #d32f2f; color: white; padding: 10px 30px; font-weight: bold; border-radius: 5px; cursor: pointer; pointer-events: auto; border: 2px solid white; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        #health-bar-container { position: absolute; top: 20px; left: 20px; width: 200px; height: 20px; background: rgba(0,0,0,0.3); border: 2px solid white; border-radius: 5px; padding: 2px; }
        #health-bar { width: 100%; height: 100%; background: #4CAF50; border-radius: 3px; transition: width 0.3s ease; }
        #ai-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 2900; display: none; align-items: center; justify-content: center; }
        #lun-aix { position: relative; width: 400px; height: 300px; background: white; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; border: 1px solid #ccc; }
        .ai-head { background: var(--primary); color: white; padding: 10px; font-weight: bold; display: flex; justify-content: space-between; cursor: pointer; }
        .ai-body { flex: 1; padding: 10px; overflow-y: auto; background: #f5f5f5; font-size: 12px; }
        .ai-in-area { padding: 10px; border-top: 1px solid #ddd; display: flex; }
        .ai-msg { padding: 8px; border-radius: 8px; margin-bottom: 5px; max-width: 80%; }
        .ai-msg.bot { background: white; border: 1px solid #ddd; } .ai-msg.user { background: #ffcdd2; margin-left: auto; }
        #script-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 3000; display: none; align-items: center; justify-content: center; }
        #script-box { width: 600px; height: 400px; background: #222; border-radius: 8px; display: flex; flex-direction: column; border: 2px solid var(--primary); }
        #code-area { flex: 1; background: #1e1e1e; color: #0f0; font-family: monospace; padding: 10px; border: none; resize: none; }
    </style>
</head>
<body onload="App.init()">

    <div id="start-screen">
        <h1 style="font-size: 40px; margin: 0;">LunX Studio</h1>
        <p>Select a template to begin</p>
        <div class="template-grid">
            <div class="template-card" onclick="World.loadTemplate('baseplate')">
                <div class="t-icon">‚¨ú</div>
                <div>Baseplate</div>
            </div>
            <div class="template-card" onclick="World.loadTemplate('grass')">
                <div class="t-icon">üü©</div>
                <div>Grass</div>
            </div>
        </div>
    </div>

    <div id="top-bar" class="ui-scaled">
        <div id="x-menu-btn" onclick="UI.toggleXMenu()">X</div>
        <div style="font-weight:bold; margin-right:20px; font-size:16px;">LunX Studio</div>
        <div class="menu-item active" onclick="UI.setRibbonTab('Home')">Home</div>
        <div class="menu-item" onclick="UI.setRibbonTab('Model')">Model</div>
        <div class="menu-item" onclick="UI.setRibbonTab('View')">View</div>
    </div>

    <div id="ribbon" class="ui-scaled">
        <div id="ribbon-content-home" class="ribbon-tab-content">
            <div class="tool-group">
                <div class="r-btn active" onclick="Editor.setMode('select')" id="btn-select"><span>üëÜ</span>Select</div>
                <div class="r-btn" onclick="Editor.setMode('translate')" id="btn-translate"><span>‚ÜîÔ∏è</span>Move</div>
                <div class="r-btn" onclick="Editor.setMode('scale')" id="btn-scale"><span>‚§°</span>Scale</div>
                <div class="r-btn" onclick="Editor.setMode('rotate')" id="btn-rotate"><span>üîÑ</span>Rotate</div>
            </div>
            <div class="tool-group">
                <div class="r-btn" onclick="World.add({name:'Part', shape:'box', color:0xd32f2f, anchored:false})"><span>üß±</span>Part</div>
                <div class="r-btn" onclick="UI.toggleToolbox()" id="btn-toolbox"><span>üß∞</span>Toolbox</div>
                <div class="r-btn" onclick="UI.toggleAI()"><span>ü§ñ</span>LunAIX</div>
            </div>
        </div>
        <div id="ribbon-content-model" class="ribbon-tab-content hidden">
             <div class="tool-group">
                <div class="r-btn" onclick="World.add({name:'Cylinder', shape:'cylinder', color:0x1565C0, anchored:false})"><span>‚≠ï</span>Cylinder</div>
                <div class="r-btn" onclick="World.add({name:'Neon', shape:'box', color:0x00E5FF, mat:'neon', anchored:false})"><span>üí°</span>Neon</div>
                <div class="r-btn" onclick="World.add({name:'Spawn', shape:'cylinder', color:0x888888, anchored:true, scale:[4,1,4]})"><span>üéØ</span>Spawn Point</div>
            </div>
        </div>
        <div id="ribbon-content-view" class="ribbon-tab-content hidden">
            <div class="tool-group">
                <div class="r-btn" onclick="App.controls.reset()"><span>üè†</span>Reset Camera</div>
                <div class="r-btn" onclick="App.scene.fog.color.set(0x000000)"><span>üåë</span>Night Mode</div>
                <div class="r-btn" onclick="App.scene.fog.color.set(0x87CEEB)"><span>‚òÄÔ∏è</span>Day Mode</div>
            </div>
        </div>

        <div id="game-controls">
            <div class="r-btn" onclick="Game.play()" style="color:green"><span>‚ñ∂</span>Play</div>
            <div class="r-btn" onclick="Game.stop()" style="color:var(--primary)"><span>‚èπ</span>Stop (Edit√∂r)</div>
        </div>
    </div>

    <div id="layout">
        <div id="toolbox" class="closed ui-scaled">
            <div class="panel-h">Toolbox <span style="float:right; cursor:pointer" onclick="UI.toggleToolbox()">‚úï</span></div>
            <div class="tab-header">
                <div class="tab-btn active" onclick="UI.setTab('basic', event)">Basic</div>
            </div>
            <div id="toolbox-list"></div>
        </div>
        <div id="viewport">
            <div id="game-overlay">
                <div id="health-bar-container"><div id="health-bar"></div></div>
                <div id="stop-btn-hud" onclick="Game.stop()">‚èπ STOP</div>
            </div>
        </div>
        <div id="properties" class="ui-scaled">
            <div class="panel-h">Explorer</div>
            <div id="explorer"></div>
            <div class="panel-h">Properties</div>
            <div id="prop-content">
                <div style="color:#888; text-align:center">No selection</div>
            </div>
        </div>
    </div>

    <div id="ai-modal" class="ui-scaled">
        <div id="lun-aix">
            <div class="ai-head">
                <span>LunAIX Assistant (v2.0)</span>
                <span style="cursor:pointer;" onclick="UI.toggleAI()">‚úï</span>
            </div>
            <div class="ai-body" id="ai-chat">
                <div class="ai-msg bot">Merhaba! Komutlarƒ±nƒ±zƒ± bekliyorum. √ñrn: "Camlƒ± ve √ßatƒ±lƒ± bir ev in≈üa et" veya "Kaydƒ±raklƒ± havuz yap"</div>
            </div>
            <div class="ai-in-area">
                <input type="text" id="ai-input" style="flex:1; padding:5px;" placeholder="Komut..." onkeydown="if(event.key==='Enter') AI.send()">
                <button onclick="AI.send()" style="margin-left:5px;">G√∂nder</button>
            </div>
        </div>
    </div>

    <div id="script-modal" class="ui-scaled">
        <div id="script-box">
            <div style="padding:10px; color:white; font-weight:bold; background:#333; border-bottom:1px solid #555; display:flex; justify-content:space-between;">
                <span>Script Editor (<span id="script-name"></span>)</span>
                <span style="cursor:pointer" onclick="document.getElementById('script-modal').style.display='none'">‚úï</span>
            </div>
            <textarea id="code-area" spellcheck="false">-- Lua Sim√ºlasyonu\nprint("Hello World")</textarea>
            <button onclick="UI.saveScript()" style="padding:10px; background:var(--primary); border:none; color:white; font-weight:bold; cursor:pointer">Apply Script</button>
        </div>
    </div>

    <script>
        /* --- CORE ENGINE (Three.js & Cannon.js) --- */
        const App = {
            scene: null, camera: null, renderer: null, controls: null, transform: null,
            clock: new THREE.Clock(),
            physicsWorld: null,
            physicsObjects: [], 
            allGameObjects: [], 
            
            init: () => {
                const vp = document.getElementById('viewport');
                
                // 1. Three.js (G√∂rsel) Sahne
                App.scene = new THREE.Scene();
                App.scene.background = new THREE.Color(0x87CEEB);
                App.scene.fog = new THREE.Fog(0x87CEEB, 40, 300);

                App.camera = new THREE.PerspectiveCamera(60, vp.clientWidth/vp.clientHeight, 0.1, 1000);
                App.camera.position.set(20, 20, 20);

                App.renderer = new THREE.WebGLRenderer({ antialias: true });
                App.renderer.setSize(vp.clientWidth, vp.clientHeight);
                App.renderer.shadowMap.enabled = true;
                vp.appendChild(App.renderer.domElement);

                const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); App.scene.add(hemi);
                const dir = new THREE.DirectionalLight(0xffffff, 0.8); 
                dir.position.set(50,100,50); dir.castShadow = true;
                dir.shadow.mapSize.width=2048; dir.shadow.mapSize.height=2048;
                App.scene.add(dir);

                App.controls = new THREE.OrbitControls(App.camera, App.renderer.domElement);
                App.transform = new THREE.TransformControls(App.camera, App.renderer.domElement);
                
                // Kontrol/D√ºzenleme Olaylarƒ±
                App.transform.addEventListener('dragging-changed', e => {
                    App.controls.enabled = !e.value;
                    if (!e.value && Editor.selected && Editor.selected.userData.body) {
                        const body = Editor.selected.userData.body;
                        body.velocity.set(0, 0, 0); body.angularVelocity.set(0, 0, 0);
                        if (App.transform.mode === 'scale') World.updatePhysicsShape(Editor.selected);
                    }
                });
                
                App.transform.addEventListener('objectChange', () => {
                    if (!Editor.selected || !Editor.selected.userData.body) return;
                    const body = Editor.selected.userData.body;
                    const mesh = Editor.selected;
                    if (App.transform.mode === 'translate' || App.transform.mode === 'rotate') {
                        body.position.copy(mesh.position);
                        body.quaternion.copy(mesh.quaternion);
                    }
                    UI.updateProps(mesh);
                });
                
                App.scene.add(App.transform);

                // 2. Cannon.js (Fizik) Sahne
                App.physicsWorld = new CANNON.World();
                App.physicsWorld.gravity.set(0, -30, 0);
                App.physicsWorld.broadphase = new CANNON.NaiveBroadphase();
                App.physicsWorld.solver.iterations = 10;
                
                const defaultMaterial = new CANNON.Material("default");
                const defaultContactMaterial = new CANNON.ContactMaterial(
                    defaultMaterial, defaultMaterial,
                    { friction: 0.4, restitution: 0.2 }
                );
                App.physicsWorld.addContactMaterial(defaultContactMaterial);
                App.physicsWorld.defaultMaterial = defaultMaterial;

                window.addEventListener('resize', App.resize);
                UI.initToolbox();
                UI.setRibbonTab('Home');
                Events.init();
                App.loop();
            },
            
            resize: () => {
                const vp = document.getElementById('viewport');
                if (!vp) return;
                App.camera.aspect = vp.clientWidth / vp.clientHeight;
                App.camera.updateProjectionMatrix();
                App.renderer.setSize(vp.clientWidth, vp.clientHeight);
            },

            loop: () => {
                requestAnimationFrame(App.loop);
                const dt = App.clock.getDelta();

                if(Game.active) Game.update(dt); else App.controls.update();

                if (App.physicsWorld) App.physicsWorld.step(1/60, dt, 3);

                for (const mesh of App.physicsObjects) {
                    if (mesh.userData.body) {
                        mesh.position.copy(mesh.userData.body.position);
                        mesh.quaternion.copy(mesh.userData.body.quaternion);
                    }
                }
                
                App.renderer.render(App.scene, App.camera);
            }
        };

        /* --- WORLD & OBJECTS (SpawnPoint & Part Handling) --- */
        const World = {
            
            loadTemplate: (type) => {
                document.getElementById('start-screen').style.display = 'none';
                
                const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
                const ctx = cvs.getContext('2d');
                const color = type==='grass' ? '#4CAF50' : '#9E9E9E';
                ctx.fillStyle = color; ctx.fillRect(0,0,64,64);
                ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.beginPath(); ctx.arc(32,32,12,0,Math.PI*2); ctx.fill();
                const tex = new THREE.CanvasTexture(cvs);
                tex.wrapS=THREE.RepeatWrapping; tex.wrapT=THREE.RepeatWrapping;
                tex.repeat.set(100, 100);

                // G√∂rsel Zemin
                const geo = new THREE.BoxGeometry(400, 4, 400);
                const mat = new THREE.MeshStandardMaterial({map:tex});
                const baseMesh = new THREE.Mesh(geo, mat);
                baseMesh.name = "Baseplate";
                baseMesh.userData = { locked: true };
                baseMesh.receiveShadow = true;
                App.scene.add(baseMesh);
                UI.addExplorer(baseMesh);
                App.allGameObjects.push(baseMesh);

                // Fiziksel Zemin
                const baseShape = new CANNON.Plane();
                const baseBody = new CANNON.Body({ mass: 0, shape: baseShape });
                baseBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                baseBody.position.y = 0;
                App.physicsWorld.addBody(baseBody);
                baseMesh.position.y = -2;
                
                // Varsayƒ±lan SpawnPoint
                World.add({
                    name:'Spawn', 
                    shape:'cylinder', 
                    color:0x888888, 
                    anchored:true, 
                    scale:[4,1,4],
                    pos: new THREE.Vector3(0, 0.5, 0)
                });
            },

            add: (config) => {
                let geo, shape;
                let scale = config.scale || [4,4,4];
                
                switch(config.shape) {
                    case 'sphere': geo = new THREE.SphereGeometry(1, 32, 32); shape = new CANNON.Sphere(0.5); break;
                    case 'cylinder': geo = new THREE.CylinderGeometry(1, 1, 1, 32); shape = new CANNON.Cylinder(0.5, 0.5, 1, 16); break;
                    default: geo = new THREE.BoxGeometry(1, 1, 1); shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
                }
                
                const isAnchored = config.anchored ?? false;
                const mass = isAnchored ? 0 : 5;

                let mat;
                if(config.mat==='neon') mat = new THREE.MeshBasicMaterial({color:config.color});
                else mat = new THREE.MeshStandardMaterial({color:config.color, roughness:0.5});
                
                if (config.op) { 
                    mat.transparent = true;
                    mat.opacity = config.op;
                    mat.side = THREE.DoubleSide;
                }

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(config.pos || new THREE.Vector3(0, 10, 0));
                mesh.scale.set(scale[0], scale[1], scale[2]);

                if (config.rot) mesh.rotation.set(config.rot[0], config.rot[1], config.rot[2]);

                mesh.name = config.name || "Part";
                mesh.castShadow = true; mesh.receiveShadow = true;
                
                const body = new CANNON.Body({ mass, material: App.physicsWorld.defaultMaterial });
                body.addShape(shape);
                World.updatePhysicsShape(mesh, body); 
                
                body.position.copy(mesh.position);
                body.quaternion.copy(mesh.quaternion);
                App.physicsWorld.addBody(body);

                mesh.userData.body = body;
                body.userData = { mesh: mesh };
                
                mesh.userData.anchored = isAnchored;
                mesh.userData.script = config.script || ""; 
                mesh.userData.size = scale;
                if (config.damage) mesh.userData.damage = config.damage;

                App.scene.add(mesh);
                App.allGameObjects.push(mesh);
                
                if (mass > 0) App.physicsObjects.push(mesh);
                
                UI.addExplorer(mesh);
                if(!Game.active) Editor.select(mesh);
                return mesh;
            },

            remove: (mesh) => {
                if (!mesh) return;
                if (mesh.userData.body) App.physicsWorld.removeBody(mesh.userData.body);
                
                let index = App.physicsObjects.indexOf(mesh);
                if (index > -1) App.physicsObjects.splice(index, 1);
                
                index = App.allGameObjects.indexOf(mesh);
                if (index > -1) App.allGameObjects.splice(index, 1);
                
                App.scene.remove(mesh);
                UI.removeExplorer(mesh);
            },
            
            updatePhysicsShape: (mesh, body = null) => {
                if (!body) body = mesh.userData.body;
                if (!body) return;
                
                const newScale = mesh.scale;
                const shape = body.shapes[0];
                
                if (shape.type === CANNON.Shape.types.BOX) {
                    shape.halfExtents.set(newScale.x / 2, newScale.y / 2, newScale.z / 2);
                } else if (shape.type === CANNON.Shape.types.SPHERE) {
                    shape.radius = Math.max(newScale.x, newScale.y, newScale.z) / 2;
                } else if (shape.type === CANNON.Shape.types.CYLINDER) {
                    shape.radiusTop = newScale.x / 2;
                    shape.radiusBottom = newScale.x / 2;
                    shape.height = newScale.y;
                }
                
                shape.updateBoundingSphereRadius();
                body.updateBoundingRadius();
                body.updateMassProperties();
            }
        };

        /* --- GAME & PLAYER (R6 Character) --- */
        const Game = {
            active: false, player: null, playerBody: null, onGround: false, 
            inputs:{x:0,y:0}, health: 100, maxHealth: 100,

            play: () => {
                if(Game.active) return;
                Game.active = true;
                Editor.deselect();
                document.getElementById('ribbon').style.display = 'none';
                document.getElementById('properties').style.display = 'none';
                document.getElementById('toolbox').classList.add('closed');
                document.getElementById('game-overlay').style.display = 'block';
                
                App.allGameObjects.forEach(mesh => {
                    if (mesh.userData.body) {
                        mesh.userData.body.position.copy(mesh.position);
                        mesh.userData.body.quaternion.copy(mesh.quaternion);
                        mesh.userData.body.velocity.set(0,0,0);
                        mesh.userData.body.angularVelocity.set(0,0,0);
                    }
                });
                
                Game.health = Game.maxHealth;
                Game.updateHealthHUD();
                Game.spawnPlayer();
            },

            stop: () => {
                Game.active = false;
                document.getElementById('ribbon').style.display = 'block';
                document.getElementById('properties').style.display = 'flex';
                document.getElementById('game-overlay').style.display = 'none';
                
                if(Game.player) World.remove(Game.player);
                Game.player = null; Game.playerBody = null;
                
                App.camera.position.set(20,20,20); 
                App.controls.target.set(0,0,0);
                App.controls.enablePan = true;
            },

            spawnPlayer: () => {
                let spawnPos = new THREE.Vector3(0, 10, 0);
                const spawnPoint = App.allGameObjects.find(obj => obj.name === "Spawn");
                if (spawnPoint) spawnPos.copy(spawnPoint.position).add(new THREE.Vector3(0, 3, 0));

                // 1. G√∂rsel Oyuncu (R6 Model)
                const g = new THREE.Group(); g.name = "Player";
                const mat = new THREE.MeshPhongMaterial({color:0xffcc80});
                const matTorso = new THREE.MeshPhongMaterial({color:0x333});

                const head = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,1.2), mat); head.position.y = 2.1;
                const torso = new THREE.Mesh(new THREE.BoxGeometry(2,2,1), matTorso); torso.position.y = 0.5;
                
                const lims = [
                    {n:'LA', x:-1.5, y:0.5, c:mat}, {n:'RA', x:1.5, y:0.5, c:mat},
                    {n:'LL', x:-0.5, y:-1.5, c:0x555}, {n:'RL', x:0.5, y:-1.5, c:0x555}
                ];
                lims.forEach(l => {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), l.c===0x555 ? new THREE.MeshPhongMaterial({color:0x555}) : l.c);
                    m.position.set(l.x, l.y, 0); m.name=l.n; g.add(m);
                });
                
                g.add(head, torso);
                
                // 2. Fiziksel Oyuncu (Kaps√ºl)
                const body = new CANNON.Body({ mass: 70, fixedRotation: true });
                const bodyShape = new CANNON.Cylinder(1, 1, 3, 16);
                body.addShape(bodyShape, new CANNON.Vec3(0, 0, 0));
                body.position.copy(spawnPos);
                App.physicsWorld.addBody(body);

                // Hasar Kontrol√º
                body.addEventListener('collide', (event) => {
                    if (!Game.active) return;
                    const otherBody = event.body;
                    if (otherBody.userData && otherBody.userData.mesh) {
                        const mesh = otherBody.userData.mesh;
                        if (mesh.userData.damage) Game.takeDamage(mesh.userData.damage);
                    }
                });

                // 3. Baƒülantƒ±
                g.userData.body = body;
                body.userData.mesh = g;
                
                App.scene.add(g);
                App.physicsObjects.push(g);
                App.allGameObjects.push(g);
                
                Game.player = g;
                Game.playerBody = body;
                App.controls.enablePan = false;

                // Kamera Oyuncuyu Takip Eder
                App.controls.target.copy(g.position.clone().add(new THREE.Vector3(0,2,0)));
                App.camera.position.copy(g.position.clone().add(new THREE.Vector3(15,10,15)));
            },
            
            update: (dt) => {
                if(!Game.playerBody) return;
                
                const pBody = Game.playerBody;
                const pMesh = Game.player;

                const yVel = pBody.velocity.y;
                Game.onGround = Math.abs(yVel) < 0.5;
                if(pBody.position.y < -50) Game.takeDamage(100);

                // R6 Hareket Logiƒüi (Klavye)
                let moveVel = new THREE.Vector3(0, pBody.velocity.y, 0);
                let isMoving = false;

                // Sim√ºle edilmi≈ü Klavye Girdisi (Hareketi saƒülamak i√ßin varsayƒ±lan)
                // Bu kƒ±sƒ±m normalde event listenerlar ile g√ºncellenir. Basitlik i√ßin sadece 0.5 sabit deƒüerini kullanƒ±yoruz
                const inputX = 0; // x ekseni (saƒü/sol)
                const inputY = 0; // y ekseni (ileri/geri)
                
                // Klavye girdisini al
                if(window.keyState) {
                    if (window.keyState['w']) Game.inputs.y = 1; else if (window.keyState['s']) Game.inputs.y = -1; else Game.inputs.y = 0;
                    if (window.keyState['a']) Game.inputs.x = -1; else if (window.keyState['d']) Game.inputs.x = 1; else Game.inputs.x = 0;
                }

                if(Math.abs(Game.inputs.x)>0.1 || Math.abs(Game.inputs.y)>0.1) {
                    isMoving = true;
                    const camD = new THREE.Vector3(); App.camera.getWorldDirection(camD); camD.y=0; camD.normalize();
                    const camR = new THREE.Vector3(-camD.z, 0, camD.x);
                    
                    const moveSpeed = 20;
                    const moveDir = camD.multiplyScalar(-Game.inputs.y).add(camR.multiplyScalar(Game.inputs.x));
                    moveDir.normalize();
                    
                    moveVel.x = moveDir.x * moveSpeed;
                    moveVel.z = moveDir.z * moveSpeed;

                    pMesh.rotation.y = Math.atan2(moveDir.x, moveDir.z);
                    
                    const t = Date.now()*0.02;
                    pMesh.getObjectByName('LA').rotation.x = Math.sin(t);
                    pMesh.getObjectByName('RA').rotation.x = -Math.sin(t);
                    pMesh.getObjectByName('LL').rotation.x = -Math.sin(t);
                    pMesh.getObjectByName('RL').rotation.x = Math.sin(t);
                } else {
                    ['LA','RA','LL','RL'].forEach(n=>pMesh.getObjectByName(n).rotation.x=0);
                }

                pBody.velocity.x = moveVel.x;
                pBody.velocity.z = moveVel.z;
                pBody.velocity.y = moveVel.y;

                App.controls.target.lerp(pMesh.position.clone().add(new THREE.Vector3(0,2,0)), 0.2);
                App.controls.update();
            },

            takeDamage: (amount) => {
                if (!Game.active || Game.health <= 0) return;
                Game.health -= amount;
                if (Game.health < 0) Game.health = 0;
                Game.updateHealthHUD();
                if (Game.health <= 0) setTimeout(Game.respawn, 500);
            },
            
            updateHealthHUD: () => {
                const bar = document.getElementById('health-bar');
                if (bar) {
                    bar.style.width = (Game.health / Game.maxHealth) * 100 + '%';
                    if (Game.health < 30) bar.style.background = '#d32f2f';
                    else if (Game.health < 60) bar.style.background = '#FFC107';
                    else bar.style.background = '#4CAF50';
                }
            },
            
            respawn: () => {
                if(Game.player) World.remove(Game.player);
                Game.health = Game.maxHealth;
                Game.updateHealthHUD();
                Game.spawnPlayer();
            },
            jump: () => { if(Game.onGround) Game.playerBody.velocity.y = 20; }
        };

        /* --- UI & EDITOR --- */
        const Editor = {
            selected: null,
            setMode: (m) => {
                App.transform.setMode(m);
                document.querySelectorAll('.r-btn').forEach(b=>{
                    if(b.id && b.id.startsWith('btn-')) b.classList.remove('active');
                });
                const btn = document.getElementById('btn-'+m);
                if(btn) btn.classList.add('active');
            },
            select: (obj) => {
                if (obj.userData.locked || obj.name === "Player") return;
                Editor.selected = obj;
                App.transform.attach(obj);
                UI.updateProps(obj);
            },
            deselect: () => { 
                Editor.selected=null; 
                App.transform.detach(); 
                UI.updateProps(null); 
            },
            deleteSelected: () => {
                if (Editor.selected) {
                    const toDelete = Editor.selected;
                    Editor.deselect();
                    World.remove(toDelete);
                }
            }
        };

        const UI = {
            toggleToolbox: () => { document.getElementById('toolbox').classList.toggle('closed'); setTimeout(App.resize, 350); },
            toggleXMenu: (force) => {
                const el = document.getElementById('x-menu');
                if(force===false) el.style.display='none';
                else el.style.display = (el.style.display === 'flex' || el.style.display === '') ? 'none' : 'flex';
            },
            toggleAI: () => {
                const modal = document.getElementById('ai-modal');
                modal.style.display = (modal.style.display === 'flex' || modal.style.display === '') ? 'none' : 'flex';
            },
            setRibbonTab: (tabName) => {
                document.querySelectorAll('.menu-item').forEach(el => el.classList.remove('active'));
                const targetMenuItem = Array.from(document.querySelectorAll('.menu-item')).find(el => el.textContent.trim() === tabName);
                if (targetMenuItem) targetMenuItem.classList.add('active');

                document.querySelectorAll('.ribbon-tab-content').forEach(el => el.classList.add('hidden'));
                document.getElementById('ribbon-content-' + tabName.toLowerCase()).classList.remove('hidden');
            },
            initToolbox: () => UI.setTab('basic'),
            setTab: (cat, event) => {
                // Basit toolbox listesi
                const list = document.getElementById('toolbox-list');
                list.innerHTML = '';
                const items = [
                    {n:'Part', s:'box', c:0xeeeeee, a:false, scale:[4,4,4]},
                    {n:'Killbrick', s:'box', c:0xFF0000, mat:'neon', scale:[5,1,5], a:true, damage:100},
                    {n:'Lava', s:'box', c:0xFF4500, mat:'neon', scale:[5,1,5], a:true, damage:20}
                ];

                items.forEach(it => {
                    const el = document.createElement('div'); el.className='tool-item';
                    el.innerHTML = `<div class="t-preview" style="background:#${new THREE.Color(it.c).getHexString()}"></div>${it.n}`;
                    el.onclick = () => World.add({name:it.n, color:it.c, shape:it.s, mat:it.mat, scale:it.scale, anchored:it.a, damage: it.damage, op: it.op});
                    list.appendChild(el);
                });
            },
            addExplorer: (obj) => {
                const d = document.createElement('div'); d.className='tree-item';
                d.id = 'tree-' + obj.uuid;
                d.innerText = (obj.name === "Player" ? "üßë " : "üì¶ ") + obj.name;
                d.onclick = () => Editor.select(obj);
                document.getElementById('explorer').appendChild(d);
            },
            removeExplorer: (obj) => {
                const el = document.getElementById('tree-' + obj.uuid);
                if (el) el.remove();
            },
            updateProps: (obj) => {
                // Basit Properties g√ºncellenmesi
                const p = document.getElementById('prop-content'); p.innerHTML = '';
                if(!obj) { p.innerHTML='<div style="color:#888">No selection</div>'; return; }
                if(obj.userData.locked) { p.innerHTML='<div style="color:#888">Baseplate is locked.</div>'; return; }
                
                const add = (lbl, el) => {
                    const r = document.createElement('div'); r.className='prop-row';
                    r.innerHTML=`<div class="prop-lbl">${lbl}</div>`; r.appendChild(el); p.appendChild(r);
                };

                const iName = document.createElement('input'); iName.className='prop-inp'; iName.value=obj.name;
                iName.oninput=e=>{ obj.name=e.target.value; document.getElementById('tree-'+obj.uuid).innerText="üì¶ " + e.target.value; };
                add('Name', iName);

                const iCol = document.createElement('input'); iCol.type='color'; iCol.value='#'+obj.material.color.getHexString();
                iCol.onchange=e=>obj.material.color.set(e.target.value);
                add('Color', iCol);
                
                const iAnch = document.createElement('input'); iAnch.type='checkbox'; iAnch.checked = obj.userData.anchored;
                iAnch.onchange = e => {
                    const anchored = e.target.checked;
                    obj.userData.anchored = anchored;
                    const body = obj.userData.body;
                    if (anchored) { body.mass = 0; } else { body.mass = 5; }
                    body.updateMassProperties();
                };
                add('Anchored', iAnch);
                
                // Script Butonu
                const btnScript = document.createElement('button');
                btnScript.innerText = "üìú Script";
                btnScript.style.width='100%'; btnScript.style.padding='5px'; btnScript.style.cursor='pointer';
                btnScript.onclick = () => UI.openScript(obj);
                p.appendChild(btnScript);
            },
            openScript: (obj) => {
                document.getElementById('script-modal').style.display = 'flex';
                document.getElementById('code-area').value = obj.userData.script || `-- ${obj.name} Script\nlocal part = script.Parent\nprint("Hello " .. part.Name)`;
                document.getElementById('script-name').innerText = obj.name;
                window.currentScriptObj = obj;
            },
            saveScript: () => {
                if(window.currentScriptObj) window.currentScriptObj.userData.script = document.getElementById('code-area').value;
                document.getElementById('script-modal').style.display = 'none';
            }
        };

        /* --- ADVANCED AI (LunAIX) KODU --- */
        const AI = {
            // Yapay Zeka Script K√ºt√ºphanesi
            scripts: {
                damage: `-- Bu kod LunAIX tarafƒ±ndan eklendi! (Sim√ºlasyon)\n\nlocal part = script.Parent\nlocal damageAmount = 20\n\nfunction onTouch(hit)\n    local humanoid = hit.Parent:findFirstChild("Humanoid")\n    if humanoid then\n        humanoid:takeDamage(damageAmount)\n    end\nend\n\npart.Touched:Connect(onTouch)\n`
            },

            send: () => {
                const i = document.getElementById('ai-input');
                const txt = i.value.trim();
                if(!txt) return;
                const d = document.createElement('div'); d.className='ai-msg user'; d.innerText=txt;
                document.getElementById('ai-chat').appendChild(d);
                i.value = '';
                document.getElementById('ai-chat').scrollTop = document.getElementById('ai-chat').scrollHeight;
                setTimeout(() => AI.process(txt), 500);
            },
            
            // YENƒ∞: Geli≈ümi≈ü NLP Sim√ºlasyonu
            process: (txt) => {
                const l = txt.toLowerCase();
                let r = "Anlayamadƒ±m. 'Camlƒ± ve √ßatƒ±lƒ± ev' veya 'kodlu lava blok' gibi komutlarƒ± deneyin.";
                const pos = new THREE.Vector3(Math.random()*20-10, 5, Math.random()*20-10);

                if((l.includes('house') || l.includes('ev')) && l.includes('camlƒ±') && l.includes('√ßatƒ±lƒ±')) {
                    AI.build.house(pos, true, true);
                    r = "Camlƒ± pencereler ve √ßatƒ±sƒ± olan detaylƒ± bir ev in≈üa ettim.";
                } else if(l.includes('house') || l.includes('ev')) {
                    AI.build.house(pos);
                    r = "Basit bir ev in≈üa ettim.";
                } else if(l.includes('havuz') && l.includes('kaydƒ±raklƒ±')) {
                    AI.build.poolWithSlide(pos);
                    r = "Kaydƒ±raklƒ± bir havuz in≈üa ettim. Sudan zƒ±plamaya √ßalƒ±≈üƒ±n!";
                } else if (l.includes('kodlu') && l.includes('lava')) {
                    AI.build.lavaBlock(pos, AI.scripts.damage);
                    r = "Hasar veren 'Lava' bloƒüu ve script'i eklendi. Bloƒüa tƒ±klayƒ±p 'Script' butonuna bakabilirsiniz.";
                } else if (l.includes('kule') || l.includes('tower')) {
                    AI.build.tower(pos);
                    r = "Yƒ±kƒ±labilir dinamik bir kule in≈üa ettim.";
                } else if(l.includes('delete') || l.includes('sil') && Editor.selected) {
                    r = Editor.selected.name + " silindi.";
                    Editor.deleteSelected();
                }

                const d = document.createElement('div'); d.className='ai-msg bot'; d.innerText=r;
                document.getElementById('ai-chat').appendChild(d);
                document.getElementById('ai-chat').scrollTop = document.getElementById('ai-chat').scrollHeight;
            },
            
            // YENƒ∞: Karma≈üƒ±k Yapƒ± Fonksiyonlarƒ±
            build: {
                house: (basePos, hasWindows=false, hasRoof=false) => {
                    const base = basePos.clone();
                    
                    // Zemin ve Duvarlar
                    World.add({name:"Floor", scale:[12,1,12], pos: base.clone().add(new THREE.Vector3(0,0.5,0)), color:0xD84315, anchored:true});
                    World.add({name:"Wall1", scale:[1,8,10], pos: base.clone().add(new THREE.Vector3(-5.5,4.5,0)), color:0xD84315, anchored:true});
                    World.add({name:"Wall2", scale:[1,8,10], pos: base.clone().add(new THREE.Vector3(5.5,4.5,0)), color:0xD84315, anchored:true});
                    World.add({name:"Wall3", scale:[12,8,1], pos: base.clone().add(new THREE.Vector3(0,4.5,-5.5)), color:0xD84315, anchored:true});
                    World.add({name:"Wall4_Door", scale:[3,8,1], pos: base.clone().add(new THREE.Vector3(4.5,4.5,5.5)), color:0x8D6E63, anchored:true});
                    World.add({name:"Wall4_Top", scale:[6,2,1], pos: base.clone().add(new THREE.Vector3(0,7.5,5.5)), color:0xD84315, anchored:true});
                    World.add({name:"Wall4_Side", scale:[3,8,1], pos: base.clone().add(new THREE.Vector3(-4.5,4.5,5.5)), color:0xD84315, anchored:true});

                    if (hasWindows) {
                         // Pencere (Camlƒ±)
                        World.add({name:"Window", scale:[0.5,3,3], pos: base.clone().add(new THREE.Vector3(5,4.5,-1)), color:0xB3E5FC, op:0.5, anchored:true});
                        World.add({name:"Window", scale:[0.5,3,3], pos: base.clone().add(new THREE.Vector3(-5,4.5,1)), color:0xB3E5FC, op:0.5, anchored:true});
                    }

                    if (hasRoof) {
                        // √áatƒ± (Wedge sim√ºlasyonu)
                        const rotX = Math.PI / 4;
                        World.add({name:"Roof1", scale:[13,10,1], pos: base.clone().add(new THREE.Vector3(0,8,0)), color:0x8D6E63, rot:[rotX, 0, 0], anchored:true});
                        World.add({name:"Roof2", scale:[13,10,1], pos: base.clone().add(new THREE.Vector3(0,8,0)), color:0x8D6E63, rot:[-rotX, 0, 0], anchored:true});
                    }
                },
                
                poolWithSlide: (basePos) => {
                    const base = basePos.clone();
                    
                    // Havuz √áevresi
                    World.add({name:"Pool_Floor", scale:[15,1,15], pos: base.clone().add(new THREE.Vector3(0,0.5,0)), color:0x4CAF50, anchored:true});
                    
                    // Havuz Su ve ƒ∞√ß Duvarlarƒ±
                    const poolBase = base.clone().add(new THREE.Vector3(0,1.5,0));
                    World.add({name:"Pool_Water", scale:[10,2,10], pos: poolBase.clone().add(new THREE.Vector3(0,0.5,0)), color:0x2196F3, op:0.7, anchored:true});
                    World.add({name:"Pool_Wall", scale:[10,3,10], pos: poolBase, color:0x90CAF9, anchored:true, canCollide: false}); // ƒ∞√ß duvarƒ± g√∂r√ºnmez yapabiliriz
                    
                    // Kaydƒ±rak (Basit eƒüimli blok)
                    const slidePos = poolBase.clone().add(new THREE.Vector3(-6, 3, 0));
                    const rotZ = -Math.PI / 8; // Hafif eƒüim
                    World.add({name:"Slide_Ramp", scale:[10,1.5,4], pos: slidePos, color:0xFFEB3B, rot:[0, 0, rotZ], anchored:true});
                    
                    // Merdiven
                    World.add({name:"Slide_Stairs1", scale:[2,1,2], pos: slidePos.clone().add(new THREE.Vector3(-4, 1.5, 0)), color:0x888888, anchored:true});
                    World.add({name:"Slide_Stairs2", scale:[2,1,2], pos: slidePos.clone().add(new THREE.Vector3(-4, 2.5, 0)), color:0x888888, anchored:true});
                    
                    // Spawnpoint'i yakƒ±nƒ±na ta≈üƒ±
                    const spawn = App.allGameObjects.find(obj => obj.name === "Spawn");
                    if (spawn) spawn.position.copy(base.clone().add(new THREE.Vector3(8, 0.5, 8)));
                },
                
                tower: (basePos) => {
                    const base = basePos.clone();
                    for(let i=0; i<8; i++) {
                        World.add({
                            name:`TowerBlock${i}`, 
                            scale:[6,1,6], 
                            pos: new THREE.Vector3(base.x, 2.5 + i*1.2, base.z), 
                            color: i % 2 === 0 ? 0x90A4AE : 0x78909C, 
                            anchored: false
                        });
                    }
                },
                
                lavaBlock: (basePos, script) => {
                    World.add({
                        name:'ScriptedLava', 
                        shape:'box', 
                        color:0xFF4500, 
                        mat:'neon', 
                        scale:[5,1,5], 
                        pos: basePos,
                        anchored:true, 
                        damage:20,
                        script: script 
                    });
                }
            }
        };

        /* --- EVENTS & INPUT --- */
        const Events = {
            init: () => {
                const vp = document.getElementById('viewport');
                window.keyState = {};
                
                // Mouse ile Se√ßim
                vp.addEventListener('pointerdown', e => {
                    if(Game.active) return;
                    if (e.target.tagName !== 'CANVAS') return;
                    if (App.transform.dragging) return;
                    
                    const rect = App.renderer.domElement.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    const ray = new THREE.Raycaster(); ray.setFromCamera({x,y}, App.camera);
                    
                    const hits = ray.intersectObjects(App.allGameObjects, true);
                    
                    if(hits.length > 0) {
                        let hitObject = hits[0].object;
                        while(hitObject.parent && !hitObject.userData.body && hitObject.parent.type !== 'Scene') hitObject = hitObject.parent;
                        if (!hitObject.userData.locked) Editor.select(hitObject); else Editor.deselect();
                    } else {
                        Editor.deselect();
                    }
                });

                // Klavye Giri≈üleri (Oyuncu Hareketi)
                document.addEventListener('keydown', (e) => {
                    if (Game.active) {
                        window.keyState[e.key.toLowerCase()] = true;
                        if (e.key.toLowerCase() === ' ') Game.jump();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (Game.active) {
                        window.keyState[e.key.toLowerCase()] = false;
                    }
                });
            }
        };
    </script>
</body>
</html>
