<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LunX Studio - Pro Edition (Physics Enabled)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <style>
        :root {
            --primary: #d32f2f; /* Roblox Kƒ±rmƒ±zƒ±sƒ± */
            --primary-dark: #b71c1c;
            --bg-light: #f5f5f5;
            --bg-panel: #ffffff;
            --border: #e0e0e0;
            --text: #333;
            --header-h: 40px;
            --ribbon-h: 100px;
            --ui-scale: 1;
        }

        * { box-sizing: border-box; user-select: none; font-family: 'Segoe UI', sans-serif; outline: none; touch-action: none; }
        body { margin: 0; overflow: hidden; background: var(--bg-light); height: 100vh; display: flex; flex-direction: column; }
        
        .ui-scaled { zoom: var(--ui-scale); }

        #start-screen {
            position: fixed; inset: 0; background: linear-gradient(135deg, #d32f2f, #ffCDD2);
            z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
        }
        .template-grid { display: flex; gap: 20px; margin-top: 30px; }
        .template-card {
            background: white; color: #333; width: 150px; height: 180px; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.3s; box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        .template-card:hover { transform: translateY(-10px); }
        .t-icon { font-size: 40px; margin-bottom: 10px; }

        #top-bar {
            height: var(--header-h); background: var(--primary); color: white; display: flex; align-items: center; padding: 0 10px;
            font-size: 14px; z-index: 100; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #x-menu-btn {
            width: 30px; height: 30px; background: white; color: var(--primary); border-radius: 4px;
            display: flex; align-items: center; justify-content: center; font-weight: 900; cursor: pointer; margin-right: 15px;
        }
        .menu-item { padding: 0 15px; cursor: pointer; opacity: 0.9; height: 100%; display: flex; align-items: center; } 
        .menu-item:hover { opacity: 1; font-weight: bold; background: rgba(255,255,255,0.1); }
        .menu-item.active { background: rgba(0,0,0,0.2); font-weight: bold; }

        #ribbon {
            height: var(--ribbon-h); background: var(--bg-panel); border-bottom: 1px solid var(--border);
            padding: 5px; flex-shrink: 0; position: relative; overflow: hidden;
        }
        .ribbon-tab-content { display: flex; gap: 5px; height: 100%; overflow-x: auto; position: absolute; top: 0; left: 0; right: 0; padding: 5px; background: inherit; }
        .ribbon-tab-content.hidden { display: none; }
        .tool-group { display: flex; gap: 5px; padding: 0 10px; border-right: 1px solid #eee; align-items: center; }
        .r-btn {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-width: 60px; height: 80px; border-radius: 5px; cursor: pointer; transition: 0.2s; color: #444;
        }
        .r-btn:hover { background: #ffebee; }
        .r-btn.active { background: #ffcdd2; color: var(--primary-dark); border: 1px solid var(--primary); }
        .r-btn span { font-size: 24px; margin-bottom: 5px; }
        
        #game-controls { position: absolute; right: 10px; top: 5px; height: 90px; display: flex; gap: 5px; align-items: center; }

        #layout { flex: 1; display: flex; position: relative; overflow: hidden; }

        #toolbox {
            width: 250px; background: var(--bg-panel); border-right: 1px solid var(--border);
            display: flex; flex-direction: column; z-index: 20; transition: width 0.3s ease; position: relative;
        }
        #toolbox.closed { width: 0; border: none; overflow: hidden; }
        .tab-header { display: flex; border-bottom: 1px solid #ddd; background: #f9f9f9; }
        .tab-btn { flex: 1; padding: 8px; text-align: center; font-size: 11px; cursor: pointer; }
        .tab-btn.active { background: white; border-bottom: 2px solid var(--primary); font-weight: bold; }
        #toolbox-list { flex: 1; overflow-y: auto; padding: 5px; display: grid; grid-template-columns: 1fr 1fr; gap: 5px; align-content: start; }
        .tool-item { 
            background: white; border: 1px solid #eee; padding: 5px; text-align: center; font-size: 10px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; border-radius: 4px;
        }
        .tool-item:hover { border-color: var(--primary); box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .t-preview { width: 30px; height: 30px; margin-bottom: 4px; border-radius: 3px; }

        #viewport { flex: 1; position: relative; background: #87CEEB; overflow: hidden; }
        
        #properties {
            width: 280px; background: var(--bg-panel); border-left: 1px solid var(--border);
            display: flex; flex-direction: column; z-index: 20;
        }
        .panel-h { padding: 8px; background: #eee; font-weight: bold; font-size: 12px; border-bottom: 1px solid #ddd; }
        #explorer { height: 35%; overflow-y: auto; border-bottom: 1px solid #ddd; }
        #prop-content { flex: 1; overflow-y: auto; padding: 10px; }
        .prop-row { display: flex; align-items: center; margin-bottom: 8px; font-size: 11px; }
        .prop-lbl { width: 40%; color: #666; }
        .prop-inp { width: 60%; padding: 4px; border: 1px solid #ccc; }

        /* HUD & OVERLAYS */
        #game-overlay { position: absolute; inset: 0; pointer-events: none; display: none; z-index: 50; }
        #stop-btn-hud {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: #d32f2f; color: white; padding: 10px 30px; font-weight: bold;
            border-radius: 5px; cursor: pointer; pointer-events: auto; border: 2px solid white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        #joystick-zone { position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px; background: rgba(255,255,255,0.2); border-radius: 50%; pointer-events: auto; border: 2px solid rgba(255,255,255,0.5); }
        #stick { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: white; border-radius: 50%; transform: translate(-50%,-50%); box-shadow: 0 2px 5px black; }
        #jump-btn { position: absolute; bottom: 50px; right: 40px; width: 80px; height: 80px; background: rgba(255,255,255,0.8); border-radius: 50%; border: 4px solid var(--primary); pointer-events: auto; cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--primary); font-weight: 900; font-size: 24px; }
        #x-menu {
            position: absolute; top: 40px; left: 10px; width: 250px; background: white; 
            border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); display: none;
            flex-direction: column; padding: 15px; z-index: 2000; border: 1px solid #ddd;
        }
        .xm-row { margin-bottom: 15px; }
        .xm-btn { width: 100%; padding: 10px; margin-bottom: 5px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }
        .btn-leave { background: #d32f2f; color: white; }
        .btn-reset { background: #ff9800; color: white; }
        .btn-close { background: #eee; color: #333; }

        /* AI CHAT MODAL */
        #ai-modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 2900;
            display: none;
            align-items: center; justify-content: center;
        }
        #lun-aix {
            position: relative;
            width: 400px; height: 300px; background: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            display: flex; flex-direction: column;
            border: 1px solid #ccc;
        }
        .ai-head { background: var(--primary); color: white; padding: 10px; font-weight: bold; display: flex; justify-content: space-between; cursor: pointer; }
        .ai-body { flex: 1; padding: 10px; overflow-y: auto; background: #f5f5f5; font-size: 12px; }
        .ai-in-area { padding: 10px; border-top: 1px solid #ddd; display: flex; }
        .ai-msg { padding: 8px; border-radius: 8px; margin-bottom: 5px; max-width: 80%; }
        .ai-msg.bot { background: white; border: 1px solid #ddd; } .ai-msg.user { background: #ffcdd2; margin-left: auto; }

        /* SCRIPT EDITOR MODAL */
        #script-modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 3000; display: none;
            align-items: center; justify-content: center;
        }
        #script-box { width: 600px; height: 400px; background: #222; border-radius: 8px; display: flex; flex-direction: column; border: 2px solid var(--primary); }
        #code-area { flex: 1; background: #1e1e1e; color: #0f0; font-family: monospace; padding: 10px; border: none; resize: none; }
        
        /* Explorer Tree */
        .tree-item { padding: 2px 5px; font-size: 12px; cursor: pointer; display: flex; align-items: center; }
        .tree-item:hover { background: #eee; }
        .tree-item.selected { background: #ffcdd2; border-left: 3px solid var(--primary); }
    </style>
</head>
<body onload="App.init()">

    <div id="start-screen">
        <h1 style="font-size: 40px; margin: 0;">LunX Studio</h1>
        <p>Select a template to begin</p>
        <div class="template-grid">
            <div class="template-card" onclick="World.loadTemplate('baseplate')">
                <div class="t-icon">‚¨ú</div>
                <div>Baseplate</div>
            </div>
            <div class="template-card" onclick="World.loadTemplate('grass')">
                <div class="t-icon">üü©</div>
                <div>Grass</div>
            </div>
            <div class="template-card" onclick="World.loadTemplate('village')">
                <div class="t-icon">üè°</div>
                <div>Village</div>
            </div>
        </div>
    </div>

    <div id="x-menu" class="ui-scaled">
        <h3 style="margin-top:0; color: var(--primary);">LunX Menu</h3>
        <div class="xm-row">
            <label>UI Scale</label>
            <input type="range" min="0.5" max="1.5" step="0.1" value="1" oninput="UI.setScale(this.value)" style="width:100%">
        </div>
        <div class="xm-row">
            <label>Quality</label>
            <select style="width:100%" onchange="App.setQuality(this.value)">
                <option value="high">High</option>
                <option value="low">Low</option>
            </select>
        </div>
        <button class="xm-btn btn-reset" onclick="Game.respawn()">Reset Character</button>
        <button class="xm-btn btn-leave" onclick="Game.stop()">Leave Game (Edit√∂r)</button>
        <button class="xm-btn btn-close" onclick="UI.toggleXMenu()">Return</button>
    </div>

    <div id="top-bar" class="ui-scaled">
        <div id="x-menu-btn" onclick="UI.toggleXMenu()">X</div>
        <div style="font-weight:bold; margin-right:20px; font-size:16px;">LunX Studio</div>
        <div class="menu-item active" onclick="UI.setRibbonTab('Home')">Home</div>
        <div class="menu-item" onclick="UI.setRibbonTab('Model')">Model</div>
        <div class="menu-item" onclick="UI.setRibbonTab('View')">View</div>
    </div>

    <div id="ribbon" class="ui-scaled">
        
        <div id="ribbon-content-home" class="ribbon-tab-content">
            <div class="tool-group">
                <div class="r-btn active" onclick="Editor.setMode('select')" id="btn-select"><span>üëÜ</span>Select</div>
                <div class="r-btn" onclick="Editor.setMode('translate')" id="btn-translate"><span>‚ÜîÔ∏è</span>Move</div>
                <div class="r-btn" onclick="Editor.setMode('scale')" id="btn-scale"><span>‚§°</span>Scale</div>
                <div class="r-btn" onclick="Editor.setMode('rotate')" id="btn-rotate"><span>üîÑ</span>Rotate</div>
            </div>
            <div class="tool-group">
                <div class="r-btn" onclick="World.add({name:'Part', shape:'box', color:0xd32f2f, anchored:false})"><span>üß±</span>Part</div> <div class="r-btn" onclick="UI.toggleToolbox()" id="btn-toolbox"><span>üß∞</span>Toolbox</div>
                <div class="r-btn" onclick="UI.toggleAI()"><span>ü§ñ</span>LunAIX</div>
            </div>
        </div>

        <div id="ribbon-content-model" class="ribbon-tab-content hidden">
            <div class="tool-group">
                <div class="r-btn" onclick="World.add({name:'Cylinder', shape:'cylinder', color:0x1565C0, anchored:false})"><span>‚≠ï</span>Cylinder</div>
                <div class="r-btn" onclick="World.add({name:'Wedge', shape:'wedge', color:0xFBC02D, anchored:false})"><span>üìê</span>Wedge</div>
                <div class="r-btn" onclick="World.add({name:'Neon', shape:'box', color:0x00E5FF, mat:'neon', anchored:false})"><span>üí°</span>Neon</div>
                <div class="r-btn" onclick="World.add('sculpt')"><span>üóø</span>Sculpt Block</div>
            </div>
            <div class="tool-group">
                <div class="r-btn" onclick="Editor.deleteSelected()"><span>üóëÔ∏è</span>Delete Selected</div>
                <div class="r-btn" onclick="World.add({name:'Spawn', shape:'cylinder', color:0x888888, anchored:true})"><span>üéØ</span>Spawn Point</div>
            </div>
        </div>

        <div id="ribbon-content-view" class="ribbon-tab-content hidden">
            <div class="tool-group">
                <div class="r-btn" onclick="App.controls.reset()"><span>üè†</span>Reset Camera</div>
                <div class="r-btn" onclick="App.scene.fog.color.set(0x000000)"><span>üåë</span>Night Mode</div>
                <div class="r-btn" onclick="App.scene.fog.color.set(0x87CEEB)"><span>‚òÄÔ∏è</span>Day Mode</div>
            </div>
            <div class="tool-group">
                <div class="r-btn" onclick="UI.toggleToolbox()"><span>‚ÜîÔ∏è</span>Toolbox Toggle</div>
                <div class="r-btn" onclick="document.getElementById('properties').style.display='none'; App.resize();"><span>‚ùå</span>Hide Properties</div>
            </div>
        </div>

        <div id="game-controls">
            <div class="r-btn" onclick="Game.play()" style="color:green"><span>‚ñ∂</span>Play</div>
            <div class="r-btn" onclick="Game.stop()" style="color:var(--primary)"><span>‚èπ</span>Stop (Edit√∂r)</div>
        </div>

    </div>

    <div id="layout" class="ui-scaled">
        
        <div id="toolbox" class="closed">
            <div class="panel-h">Toolbox <span style="float:right; cursor:pointer" onclick="UI.toggleToolbox()">‚úï</span></div>
            <div class="tab-header">
                <div class="tab-btn active" onclick="UI.setTab('basic', event)">Basic</div>
                <div class="tab-btn" onclick="UI.setTab('nature', event)">Nature</div>
                <div class="tab-btn" onclick="UI.setTab('struct', event)">Struct</div>
            </div>
            <div id="toolbox-list"></div>
        </div>

        <div id="viewport">
            <div id="game-overlay">
                <div id="stop-btn-hud" onclick="Game.stop()">‚èπ STOP</div>
                <div id="joystick-zone"><div id="stick"></div></div>
                <div id="jump-btn">‚¨Ü</div>
            </div>
        </div>

        <div id="properties">
            <div class="panel-h">Explorer</div>
            <div id="explorer"></div>
            <div class="panel-h">Properties</div>
            <div id="prop-content">
                <div style="color:#888; text-align:center">No selection</div>
            </div>
        </div>

    </div>

    <div id="ai-modal">
        <div id="lun-aix">
            <div class="ai-head">
                <span>LunAIX Assistant</span>
                <span style="cursor:pointer;" onclick="UI.toggleAI()">‚úï</span>
            </div>
            <div class="ai-body" id="ai-chat">
                <div class="ai-msg bot">Hello! I can build structures or run commands. Try "Build a house". (Physics engine is now active!)</div>
            </div>
            <div class="ai-in-area">
                <input type="text" id="ai-input" style="flex:1; padding:5px;" placeholder="Command..." onkeydown="if(event.key==='Enter') AI.send()">
                <button onclick="AI.send()" style="margin-left:5px;">Send</button>
            </div>
        </div>
    </div>

    <div id="script-modal">
        <div id="script-box">
            <div style="padding:10px; color:white; font-weight:bold; background:#333; border-bottom:1px solid #555; display:flex; justify-content:space-between;">
                <span>Script Editor (<span id="script-name"></span>)</span>
                <span style="cursor:pointer" onclick="document.getElementById('script-modal').style.display='none'">‚úï</span>
            </div>
            <textarea id="code-area" spellcheck="false">-- Lua Sim√ºlasyonu\nprint("Hello World")</textarea>
            <button onclick="UI.saveScript()" style="padding:10px; background:var(--primary); border:none; color:white; font-weight:bold; cursor:pointer">Apply Script</button>
        </div>
    </div>

    <script>
        /* --- CORE ENGINE (Fƒ∞Zƒ∞K MOTORU ƒ∞LE YENƒ∞DEN YAZILDI) --- */
        const App = {
            scene: null, camera: null, renderer: null, controls: null, transform: null,
            clock: new THREE.Clock(),
            
            physicsWorld: null, // YENƒ∞: Cannon.js d√ºnyasƒ±
            physicsObjects: [], // YENƒ∞: G√∂rsel ve fiziksel nesneleri senkronize etmek i√ßin
            
            init: () => {
                const vp = document.getElementById('viewport');
                
                // 1. Three.js (G√∂rsel) Sahne
                App.scene = new THREE.Scene();
                App.scene.background = new THREE.Color(0x87CEEB);
                App.scene.fog = new THREE.Fog(0x87CEEB, 40, 300);

                App.camera = new THREE.PerspectiveCamera(60, vp.clientWidth/vp.clientHeight, 0.1, 1000);
                App.camera.position.set(20, 20, 20);

                App.renderer = new THREE.WebGLRenderer({ antialias: true });
                App.renderer.setSize(vp.clientWidth, vp.clientHeight);
                App.renderer.shadowMap.enabled = true;
                vp.appendChild(App.renderer.domElement);

                const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); App.scene.add(hemi);
                const dir = new THREE.DirectionalLight(0xffffff, 0.8); 
                dir.position.set(50,100,50); dir.castShadow = true;
                dir.shadow.mapSize.width=2048; dir.shadow.mapSize.height=2048;
                App.scene.add(dir);

                App.controls = new THREE.OrbitControls(App.camera, App.renderer.domElement);
                App.transform = new THREE.TransformControls(App.camera, App.renderer.domElement);
                App.transform.addEventListener('dragging-changed', e => App.controls.enabled = !e.value);
                
                // YENƒ∞: Edit√∂r bir nesneyi hareket ettirdiƒüinde, fizik bedenini de g√ºncelle
                App.transform.addEventListener('objectChange', () => {
                    if(Editor.selected && Editor.selected.userData.body) {
                        const body = Editor.selected.userData.body;
                        body.position.copy(Editor.selected.position);
                        body.quaternion.copy(Editor.selected.quaternion);
                        body.velocity.set(0,0,0); // S√ºr√ºklerken hƒ±zƒ± sƒ±fƒ±rla
                        body.angularVelocity.set(0,0,0);
                    }
                    UI.updateProps(Editor.selected);
                });
                
                App.scene.add(App.transform);

                // 2. Cannon.js (Fizik) Sahne
                App.physicsWorld = new CANNON.World();
                App.physicsWorld.gravity.set(0, -30, 0); // Daha g√º√ßl√º yer√ßekimi
                App.physicsWorld.broadphase = new CANNON.NaiveBroadphase();
                App.physicsWorld.solver.iterations = 10;

                // YENƒ∞: Varsayƒ±lan temas materyali (s√ºrt√ºnme, esneklik)
                const defaultMaterial = new CANNON.Material("default");
                const defaultContactMaterial = new CANNON.ContactMaterial(
                    defaultMaterial, defaultMaterial,
                    { friction: 0.4, restitution: 0.2 }
                );
                App.physicsWorld.addContactMaterial(defaultContactMaterial);
                App.physicsWorld.defaultMaterial = defaultMaterial;


                window.addEventListener('resize', App.resize);
                UI.initToolbox();
                UI.setRibbonTab('Home');
                Events.init();
                App.loop();
            },
            
            resize: () => {
                const vp = document.getElementById('viewport');
                App.camera.aspect = vp.clientWidth / vp.clientHeight;
                App.camera.updateProjectionMatrix();
                App.renderer.setSize(vp.clientWidth, vp.clientHeight);
            },

            setQuality: (q) => {
                App.renderer.setPixelRatio(q==='high' ? window.devicePixelRatio : 0.5);
            },

            loop: () => {
                requestAnimationFrame(App.loop);
                const dt = App.clock.getDelta();

                if(Game.active) {
                    Game.update(dt);
                } else {
                    App.controls.update();
                }

                // YENƒ∞: Fizik d√ºnyasƒ±nƒ± g√ºncelle
                if (App.physicsWorld) {
                    App.physicsWorld.step(1/60, dt, 3); // Sabit adƒ±mda fizik hesapla
                }

                // YENƒ∞: G√∂rsel nesneleri fiziksel nesnelerin pozisyonuna g√ºncelle
                for (const mesh of App.physicsObjects) {
                    if (mesh.userData.body) {
                        mesh.position.copy(mesh.userData.body.position);
                        mesh.quaternion.copy(mesh.userData.body.quaternion);
                    }
                }
                
                App.renderer.render(App.scene, App.camera);
            }
        };

        /* --- WORLD & OBJECTS (Fƒ∞Zƒ∞K MOTORU ƒ∞LE YENƒ∞DEN YAZILDI) --- */
        const World = {
            
            loadTemplate: (type) => {
                document.getElementById('start-screen').style.display = 'none';
                
                const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
                const ctx = cvs.getContext('2d');
                const color = type==='grass' || type==='village' ? '#4CAF50' : '#9E9E9E';
                ctx.fillStyle = color; ctx.fillRect(0,0,64,64);
                ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.beginPath(); ctx.arc(32,32,12,0,Math.PI*2); ctx.fill();
                const tex = new THREE.CanvasTexture(cvs);
                tex.wrapS=THREE.RepeatWrapping; tex.wrapT=THREE.RepeatWrapping;
                tex.repeat.set(100, 100);

                // 1. G√∂rsel Zemin
                const geo = new THREE.BoxGeometry(400, 4, 400);
                const mat = new THREE.MeshStandardMaterial({map:tex});
                const baseMesh = new THREE.Mesh(geo, mat);
                baseMesh.position.y = -2;
                baseMesh.name = "Baseplate";
                baseMesh.userData = { locked: true }; // Edit√∂rde se√ßilemez/ta≈üƒ±namaz
                baseMesh.receiveShadow = true;
                App.scene.add(baseMesh);
                UI.addExplorer(baseMesh);

                // 2. Fiziksel Zemin (G√∂r√ºnmez d√ºzlem)
                const baseShape = new CANNON.Plane();
                const baseBody = new CANNON.Body({ mass: 0, shape: baseShape }); // mass: 0 = static (sabit)
                baseBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // D√ºzlemi yatay yap
                baseBody.position.y = 0; // Zemin tam 0 koordinatƒ±nda
                App.physicsWorld.addBody(baseBody);
                
                baseMesh.position.y = 0; // G√∂rsel zemini de fiziksel zeminle hizala
                
                if(type==='village') AI.build('house');
            },

            add: (config) => {
                let geo, shape;
                let scale = config.scale || [4,4,4];
                
                // 1. Fiziksel ≈ûekli ve K√ºtleyi Belirle
                switch(config.shape) {
                    case 'sphere':
                        geo = new THREE.SphereGeometry(scale[0]/2, 32, 32);
                        shape = new CANNON.Sphere(scale[0]/2);
                        break;
                    case 'cylinder':
                        geo = new THREE.CylinderGeometry(scale[0]/2, scale[0]/2, scale[1], 32);
                        shape = new CANNON.Cylinder(scale[0]/2, scale[0]/2, scale[1], 32);
                        break;
                    case 'wedge':
                        geo = new THREE.ConeGeometry(scale[0]/2, scale[1], 4); 
                        // Not: Cannon.js'de "wedge" (kama) yok, Box kullanƒ±yoruz
                        shape = new CANNON.Box(new CANNON.Vec3(scale[0] / 2, scale[1] / 2, scale[2] / 2));
                        break;
                    case 'sculpt':
                        geo = new THREE.BoxGeometry(10,5,10); scale=[1,1,1]; config.color=0x8D6E63;
                        shape = new CANNON.Box(new CANNON.Vec3(5, 2.5, 5));
                        break;
                    default: // 'box'
                        geo = new THREE.BoxGeometry(scale[0], scale[1], scale[2]);
                        shape = new CANNON.Box(new CANNON.Vec3(scale[0] / 2, scale[1] / 2, scale[2] / 2));
                }
                
                const isAnchored = config.anchored ?? false; // Varsayƒ±lan olarak nesneler artƒ±k dinamik
                const mass = isAnchored ? 0 : scale[0] * scale[1] * scale[2] * 0.1; // K√ºtleyi hacme g√∂re ayarla

                // 2. G√∂rsel Nesneyi (Mesh) Olu≈ütur
                let mat;
                if(config.mat==='neon') mat = new THREE.MeshBasicMaterial({color:config.color});
                else mat = new THREE.MeshStandardMaterial({color:config.color, roughness:0.5});

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(config.pos || new THREE.Vector3(0, 10, 0));
                
                if (config.shape === 'wedge') { // Kama'yƒ± doƒüru d√∂nd√ºr
                    mesh.rotation.y = Math.PI / 4;
                }

                mesh.name = config.name || "Part";
                mesh.castShadow = true; mesh.receiveShadow = true;
                
                // 3. Fiziksel Nesneyi (Body) Olu≈ütur
                const body = new CANNON.Body({ mass, shape, material: App.physicsWorld.defaultMaterial });
                body.position.copy(mesh.position);
                body.quaternion.copy(mesh.quaternion);
                App.physicsWorld.addBody(body);

                // 4. ƒ∞kisini Birbirine Baƒüla
                mesh.userData.body = body; // Mesh, fizik bedenine referans tutar
                body.userData = { mesh: mesh }; // Body, g√∂rsele referans tutar
                
                mesh.userData.anchored = isAnchored;
                mesh.userData.canCollide = config.canCollide ?? true;
                mesh.userData.script = "";
                mesh.userData.size = scale; // Bu hala props i√ßin yararlƒ±

                App.scene.add(mesh);
                
                // Sadece hareket edecek nesneleri senkronizasyon listesine ekle
                if (mass > 0) {
                    App.physicsObjects.push(mesh);
                }
                
                UI.addExplorer(mesh);
                if(!Game.active) Editor.select(mesh);
                return mesh;
            },

            remove: (mesh) => {
                if (!mesh) return;
                
                // 1. Fizik d√ºnyasƒ±ndan kaldƒ±r
                if (mesh.userData.body) {
                    App.physicsWorld.removeBody(mesh.userData.body);
                }
                
                // 2. Senkronizasyon listesinden kaldƒ±r
                const index = App.physicsObjects.indexOf(mesh);
                if (index > -1) {
                    App.physicsObjects.splice(index, 1);
                }
                
                // 3. G√∂rsel d√ºnyadan (Scene) kaldƒ±r
                App.scene.remove(mesh);
                
                // 4. Explorer'dan kaldƒ±r
                UI.removeExplorer(mesh);
            }
        };

        /* --- GAME & PLAYER (Fƒ∞Zƒ∞K MOTORU ƒ∞LE YENƒ∞DEN YAZILDI) --- */
        const Game = {
            active: false, 
            player: null, // Three.js Group
            playerBody: null, // CANNON.Body
            onGround: false, 
            inputs:{x:0,y:0},

            play: () => {
                if(Game.active) return;
                Game.active = true;
                Editor.deselect();
                document.getElementById('ribbon').style.display = 'none';
                document.getElementById('properties').style.display = 'none';
                document.getElementById('toolbox').classList.add('closed');
                document.getElementById('game-overlay').style.display = 'block';
                UI.toggleXMenu(false);
                setTimeout(App.resize, 350);
                
                // T√ºm dinamik nesnelerin edit√∂rdeki pozisyonunu fiziƒüe senkronize et
                App.physicsObjects.forEach(mesh => {
                    mesh.userData.body.position.copy(mesh.position);
                    mesh.userData.body.quaternion.copy(mesh.quaternion);
                    mesh.userData.body.velocity.set(0,0,0);
                    mesh.userData.body.angularVelocity.set(0,0,0);
                });
                
                Game.spawnPlayer();
            },

            stop: () => {
                Game.active = false;
                document.getElementById('ribbon').style.display = 'block';
                document.getElementById('properties').style.display = 'flex';
                document.getElementById('game-overlay').style.display = 'none';
                
                if(Game.player) {
                    World.remove(Game.player); // Oyuncuyu d√ºnyadan d√ºzg√ºnce kaldƒ±r
                    Game.player = null;
                    Game.playerBody = null;
                }
                
                App.camera.position.set(20,20,20); App.controls.target.set(0,0,0); App.controls.enablePan=true;
                
                setTimeout(App.resize, 350);
            },

            respawn: () => {
                if(Game.player) {
                    World.remove(Game.player);
                }
                Game.spawnPlayer();
            },

            spawnPlayer: () => {
                // 1. G√∂rsel Oyuncu (R6)
                const g = new THREE.Group(); g.name = "Player";
                const mat = new THREE.MeshPhongMaterial({color:0xffcc80});
                const matTorso = new THREE.MeshPhongMaterial({color:0x333});

                const head = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,1.2), mat); head.position.y=2.1;
                const torso = new THREE.Mesh(new THREE.BoxGeometry(2,2,1), matTorso); torso.position.y=0.5;
                
                const xCvs = document.createElement('canvas'); xCvs.width=64; xCvs.height=64;
                const ctx = xCvs.getContext('2d');
                ctx.fillStyle = '#333'; ctx.fillRect(0,0,64,64);
                ctx.strokeStyle = 'white'; ctx.lineWidth=5; 
                ctx.moveTo(10,10); ctx.lineTo(54,54); ctx.moveTo(54,10); ctx.lineTo(10,54); ctx.stroke();
                const decal = new THREE.Mesh(new THREE.PlaneGeometry(1,1), new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(xCvs), transparent:true}));
                decal.position.set(0, 0.5, 0.51); g.add(decal);

                const lims = [
                    {n:'LA', x:-1.5, y:0.5, c:mat}, {n:'RA', x:1.5, y:0.5, c:mat},
                    {n:'LL', x:-0.5, y:-1.5, c:0x555}, {n:'RL', x:0.5, y:-1.5, c:0x555}
                ];
                lims.forEach(l => {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), l.c===0x555 ? new THREE.MeshPhongMaterial({color:0x555}) : l.c);
                    m.position.set(l.x, l.y, 0); m.name=l.n; g.add(m);
                });
                
                g.add(head, torso);
                
                // 2. Fiziksel Oyuncu (G√∂r√ºnmez Kaps√ºl/K√ºre)
                // Not: Cannon.js'de Capsule yok, basitlik i√ßin Sphere+Box kullanacaƒüƒ±z
                const playerShape = new CANNON.Sphere(1.5); // Kafa ve g√∂vdeyi kapsayan bir k√ºre
                const body = new CANNON.Body({
                    mass: 70, 
                    shape: playerShape, 
                    fixedRotation: true, // Oyuncunun fiziksel olarak devrilmesini engelle
                    material: App.physicsWorld.defaultMaterial
                });
                body.position.set(0, 10, 0);
                App.physicsWorld.addBody(body);

                // 3. Baƒülantƒ±
                g.userData.body = body;
                body.userData.mesh = g;
                
                App.scene.add(g);
                App.physicsObjects.push(g); // Oyuncuyu senkronizasyon listesine ekle
                
                Game.player = g;
                Game.playerBody = body;
                App.controls.enablePan = false;
            },

            update: (dt) => {
                if(!Game.playerBody) return;
                
                const pBody = Game.playerBody;
                const pMesh = Game.player;

                // Yerde olup olmadƒ±ƒüƒ±nƒ± kontrol et
                const yVel = pBody.velocity.y;
                Game.onGround = Math.abs(yVel) < 0.5; // Hƒ±zƒ± √ßok azsa yerdedir (basit kontrol)

                // Death Zone
                if(pBody.position.y < -50) Game.respawn();

                // Hareket
                const camD = new THREE.Vector3(); App.camera.getWorldDirection(camD); camD.y=0; camD.normalize();
                const camR = new THREE.Vector3(-camD.z, 0, camD.x);
                
                const moveSpeed = 20;
                let moveVel = new THREE.Vector3(0, pBody.velocity.y, 0); // Y hƒ±zƒ±nƒ± koru

                if(Math.abs(Game.inputs.x)>0.1 || Math.abs(Game.inputs.y)>0.1) {
                    const moveDir = camD.multiplyScalar(-Game.inputs.y).add(camR.multiplyScalar(Game.inputs.x));
                    moveDir.normalize();
                    
                    moveVel.x = moveDir.x * moveSpeed;
                    moveVel.z = moveDir.z * moveSpeed;

                    pMesh.rotation.y = Math.atan2(moveDir.x, moveDir.z); // G√∂rsel modeli d√∂nd√ºr
                    
                    // Y√ºr√ºme animasyonu (basit)
                    const t = Date.now()*0.02;
                    pMesh.getObjectByName('LA').rotation.x = Math.sin(t);
                    pMesh.getObjectByName('RA').rotation.x = -Math.sin(t);
                    pMesh.getObjectByName('LL').rotation.x = -Math.sin(t);
                    pMesh.getObjectByName('RL').rotation.x = Math.sin(t);
                } else {
                    moveVel.x = 0;
                    moveVel.z = 0;
                    ['LA','RA','LL','RL'].forEach(n=>pMesh.getObjectByName(n).rotation.x=0);
                }

                pBody.velocity.x = moveVel.x;
                pBody.velocity.z = moveVel.z;
                pBody.velocity.y = moveVel.y; // Y hƒ±zƒ±nƒ± (zƒ±plama/d√º≈üme) koru

                // Kamera oyuncunun fiziksel bedenini takip eder
                // (Senkronizasyon lsitesi mesh'i g√ºncellediƒüi i√ßin mesh'i takip etmek yeterli)
                App.controls.target.lerp(pMesh.position.clone().add(new THREE.Vector3(0,2,0)), 0.2);
                App.controls.update();
            },
            
            jump: () => { 
                if(Game.onGround) {
                    Game.playerBody.velocity.y = 25; // Zƒ±plama hƒ±zƒ±
                }
            }
        };

        /* --- UI & EDITOR (Fƒ∞Zƒ∞K ƒ∞LE G√úNCELLENDƒ∞) --- */
        const Editor = {
            selected: null,
            setMode: (m) => {
                // YENƒ∞: Scale modu fizik motoruyla d√ºzg√ºn √ßalƒ±≈ümaz, ≈üimdilik devre dƒ±≈üƒ±
                if (m === 'scale') {
                    alert("Scale modu fizik motoruyla ge√ßici olarak uyumsuzdur.");
                    return; 
                }
                App.transform.setMode(m);
                document.querySelectorAll('.r-btn').forEach(b=>{
                    if(b.id && b.id.startsWith('btn-')) b.classList.remove('active');
                });
                const btn = document.getElementById('btn-'+m);
                if(btn) btn.classList.add('active');
            },
            select: (obj) => {
                if (obj.userData.locked) return; // Kilitli nesneleri (Baseplate) se√ßme
                Editor.selected = obj;
                App.transform.attach(obj);
                UI.updateProps(obj);
            },
            deselect: () => { 
                Editor.selected=null; 
                App.transform.detach(); 
                UI.updateProps(null); 
            },
            deleteSelected: () => {
                if (Editor.selected) {
                    const toDelete = Editor.selected;
                    Editor.deselect();
                    World.remove(toDelete); // D√ºzg√ºn kaldƒ±rma fonksiyonunu kullan
                }
            }
        };

        const UI = {
            toggleToolbox: () => { 
                document.getElementById('toolbox').classList.toggle('closed'); 
                setTimeout(App.resize, 350);
            },
            toggleXMenu: (force) => {
                const el = document.getElementById('x-menu');
                if(force===false) el.style.display='none';
                else el.style.display = (el.style.display==='flex' || el.style.display==='') ? 'none' : 'flex'; // Hata d√ºzeltildi
            },
            setScale: (v) => document.documentElement.style.setProperty('--ui-scale', v),
            
            toggleAI: () => {
                const modal = document.getElementById('ai-modal');
                // Hata d√ºzeltildi: .style.display inline stili okur, CSS'i deƒüil.
                // Bunun yerine getComputedStyle kullanmak daha saƒülamdƒ±r veya basit√ße mevcut durumu kontrol edin
                modal.style.display = (modal.style.display === 'flex' || modal.style.display === '') ? 'none' : 'flex';
            },

            setRibbonTab: (tabName) => {
                document.querySelectorAll('.menu-item').forEach(el => el.classList.remove('active'));
                const targetMenuItem = Array.from(document.querySelectorAll('.menu-item')).find(el => el.textContent.trim() === tabName);
                if (targetMenuItem) targetMenuItem.classList.add('active');

                document.querySelectorAll('.ribbon-tab-content').forEach(el => el.classList.add('hidden'));
                document.getElementById('ribbon-content-' + tabName.toLowerCase()).classList.remove('hidden');
            },

            initToolbox: () => {
                UI.setTab('basic');
            },
            setTab: (cat, event) => {
                document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active'));
                if(event && event.target) event.target.classList.add('active');
                
                const list = document.getElementById('toolbox-list');
                list.innerHTML = '';
                
                const items = [];
                // Not: anchored:true olanlar sabit, olmayanlar dinamik olacak
                if(cat==='basic') {
                    items.push({n:'Part', s:'box', c:0xeeeeee, a:false});
                    items.push({n:'Sphere', s:'sphere', c:0xeeeeee, a:false});
                    items.push({n:'Cylinder', s:'cylinder', c:0xeeeeee, a:false});
                    items.push({n:'Wedge', s:'wedge', c:0xeeeeee, a:false});
                    items.push({n:'Spawn', s:'cylinder', c:0x888888, a:true});
                } else if(cat==='nature') {
                    items.push({n:'Grass', s:'box', c:0x4CAF50, scale:[5,1,5], a:true});
                    items.push({n:'Wood', s:'box', c:0x795548, scale:[1,6,1], a:false});
                    items.push({n:'Water', s:'box', c:0x2196F3, a:true, scale:[10,0.5,10]});
                    items.push({n:'Rock', s:'sphere', c:0x6D4C41, scale:[2,2,2], a:false});
                } else {
                    items.push({n:'Wall', s:'box', c:0x9E9E9E, scale:[1,5,8], a:true});
                    items.push({n:'Window', s:'box', c:0xB3E5FC, op:0.5, scale:[0.1,3,3], a:true});
                    items.push({n:'Neon', s:'box', c:0x00FFFF, mat:'neon', scale:[4,1,1], a:false});
                    items.push({n:'Killbrick', s:'box', c:0xFF0000, mat:'neon', scale:[5,1,5], a:true, damage:100});
                }

                items.forEach(it => {
                    const el = document.createElement('div'); el.className='tool-item';
                    el.innerHTML = `<div class="t-preview" style="background:#${new THREE.Color(it.c).getHexString()}"></div>${it.n}`;
                    el.onclick = () => World.add({name:it.n, color:it.c, shape:it.s, mat:it.mat, scale:it.scale, anchored:it.a});
                    list.appendChild(el);
                });
            },

            addExplorer: (obj) => {
                const d = document.createElement('div'); d.className='tree-item';
                d.id = 'tree-' + obj.uuid;
                d.innerText = "üì¶ " + obj.name;
                d.onclick = () => Editor.select(obj);
                document.getElementById('explorer').appendChild(d);
            },
            
            removeExplorer: (obj) => {
                const el = document.getElementById('tree-' + obj.uuid);
                if (el) el.remove();
            },

            updateProps: (obj) => {
                const p = document.getElementById('prop-content'); p.innerHTML = '';
                if(!obj) { p.innerHTML='<div style="color:#888">No selection</div>'; return; }
                if(obj.userData.locked) { p.innerHTML='<div style="color:#888">Baseplate is locked.</div>'; return; }


                const add = (lbl, el) => {
                    const r = document.createElement('div'); r.className='prop-row';
                    r.innerHTML=`<div class="prop-lbl">${lbl}</div>`; r.appendChild(el); p.appendChild(r);
                };

                const iName = document.createElement('input'); iName.className='prop-inp'; iName.value=obj.name;
                iName.oninput=e=>{ obj.name=e.target.value; document.getElementById('tree-'+obj.uuid).innerText="üì¶ " + e.target.value; };
                add('Name', iName);

                const iCol = document.createElement('input'); iCol.type='color'; iCol.value='#'+obj.material.color.getHexString();
                iCol.onchange=e=>obj.material.color.set(e.target.value);
                add('Color', iCol);

                // YENƒ∞: Anchored √∂zelliƒüi artƒ±k Fƒ∞Zƒ∞ƒûƒ∞ etkiliyor
                const iAnch = document.createElement('input'); iAnch.type='checkbox'; iAnch.checked = obj.userData.anchored;
                iAnch.onchange = e => {
                    const anchored = e.target.checked;
                    obj.userData.anchored = anchored;
                    const body = obj.userData.body;
                    
                    if (anchored) {
                        body.mass = 0; // K√ºtleyi sƒ±fƒ±rla (sabitlenir)
                        body.velocity.set(0,0,0);
                        body.angularVelocity.set(0,0,0);
                        // Senkronizasyon listesinden √ßƒ±kar
                        const index = App.physicsObjects.indexOf(obj);
                        if (index > -1) App.physicsObjects.splice(index, 1);
                    } else {
                        const scale = obj.userData.size;
                        body.mass = scale[0] * scale[1] * scale[2] * 0.1; // K√ºtleyi tekrar hesapla
                        // Senkronizasyon listesine ekle
                        if (App.physicsObjects.indexOf(obj) === -1) {
                            App.physicsObjects.push(obj);
                        }
                    }
                    body.updateMassProperties(); // K√ºtle deƒüi≈üikliƒüini uygula
                };
                add('Anchored', iAnch);

                const iColl = document.createElement('input'); iColl.type='checkbox'; iColl.checked=obj.userData.canCollide;
                iColl.onchange=e=>obj.userData.canCollide=e.target.checked;
                add('CanCollide', iColl);
                
                const btnScript = document.createElement('button');
                btnScript.innerText = "üìú Script"; btnScript.style.width='100%';
                btnScript.onclick = () => UI.openScript(obj);
                p.appendChild(btnScript);
            },

            openScript: (obj) => {
                document.getElementById('script-modal').style.display = 'flex';
                document.getElementById('code-area').value = obj.userData.script || `-- ${obj.name} Script\nlocal part = script.Parent\nprint("Hello " .. part.Name)`;
                document.getElementById('script-name').innerText = obj.name;
                window.currentScriptObj = obj;
            },
            saveScript: () => {
                if(window.currentScriptObj) window.currentScriptObj.userData.script = document.getElementById('code-area').value;
                document.getElementById('script-modal').style.display = 'none';
            }
        };

        /* --- AI (Fƒ∞Zƒ∞K ƒ∞LE G√úNCELLENDƒ∞) --- */
        const AI = {
            send: () => {
                const i = document.getElementById('ai-input');
                const txt = i.value.trim();
                if(!txt) return;
                const d = document.createElement('div'); d.className='ai-msg user'; d.innerText=txt;
                document.getElementById('ai-chat').appendChild(d);
                i.value = '';
                document.getElementById('ai-chat').scrollTop = document.getElementById('ai-chat').scrollHeight;
                setTimeout(() => AI.process(txt), 500);
            },
            process: (txt) => {
                const l = txt.toLowerCase();
                let r = "I can build 'house' or 'tower'. (Physics is now active!)";
                
                if(l.includes('house') || l.includes('ev')) {
                    AI.build('house'); r = "Fiziksel bir ev in≈üa ettim (duvarlar sabitlendi).";
                } else if(l.includes('tower') || l.includes('kule')) {
                    AI.build('tower'); r = "Dinamik (yƒ±kƒ±labilir) bir kule in≈üa ettim.";
                } else if(l.includes('delete') || l.includes('sil') && Editor.selected) {
                    r = Editor.selected.name + " silindi.";
                    Editor.deleteSelected();
                } else if(l.includes('red') || l.includes('kƒ±rmƒ±zƒ±')) {
                    World.add({name:'RedBlock', shape:'box', color:0xFF0000, scale:[5,5,5], anchored: false}); r = "Kƒ±rmƒ±zƒ± dinamik blok eklendi.";
                } else if (l.includes('araba') || l.includes('car')) {
                    r = "Fizik motoru artƒ±k aktif! Ancak 's√ºr√ºlebilir bir araba', tekerlekler ve motor i√ßin (RaycastVehicle) √∂zel kodlama gerektiren √ßok karma≈üƒ±k bir sistemdir. Hen√ºz bunu in≈üa edemiyorum.";
                }
                
                const d = document.createElement('div'); d.className='ai-msg bot'; d.innerText=r;
                document.getElementById('ai-chat').appendChild(d);
                document.getElementById('ai-chat').scrollTop = document.getElementById('ai-chat').scrollHeight;
            },
            build: (type) => {
                if(type==='house') {
                    // Evi sabit (anchored: true) yapƒ±yoruz
                    World.add({name:"Wall1", scale:[1,8,10], pos:new THREE.Vector3(-5,4,0), color:0xD84315, anchored:true});
                    // *** HATA D√úZELTƒ∞LDƒ∞: 1G -> 1 ***
                    World.add({name:"Wall2", scale:[1,8,10], pos:new THREE.Vector3(5,4,0), color:0xD84315, anchored:true});
                    World.add({name:"Roof", shape:'wedge', scale:[12,4,12], pos:new THREE.Vector3(0,9,0), color:0x8D6E63, anchored:true});
                    World.add({name:"Floor", scale:[12,1,12], pos:new THREE.Vector3(0,0.5,0), color:0xD84315, anchored:true});
                } else if (type==='tower') {
                    // Kuleyi dinamik (anchored: false) yapƒ±yoruz, yƒ±kƒ±labilir
                    for(let i=0; i<5; i++) World.add({name:"Floor"+i, scale:[5,1,5], pos:new THREE.Vector3(10, 2.5 + i*1, 10), color:0x424242, anchored: false});
                }
            }
        };

        /* --- EVENTS & INPUT --- */
        const Events = {
            init: () => {
                const vp = document.getElementById('viewport');
                vp.addEventListener('pointerdown', e => {
                    if(Game.active) return;
                    if (e.target.tagName !== 'CANVAS') return; // Sadece viewport'a tƒ±klanƒ±rsa
                    
                    const rect = App.renderer.domElement.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    const ray = new THREE.Raycaster(); ray.setFromCamera({x,y}, App.camera);
                    
                    // Artƒ±k 'App.physicsObjects' yerine sahnedeki t√ºm nesneleri (Baseplate hari√ß) kontrol et
                    const selectableObjects = App.scene.children.filter(o => o.isMesh && !o.userData.locked);
                    const hits = ray.intersectObjects(selectableObjects);
                    
                    if(hits.length > 0 && !App.transform.dragging) {
                        Editor.select(hits[0].object);
                    } else if(hits.length===0 && !App.transform.dragging) {
                        Editor.deselect();
                    }
                });

                // Joystick
                const joy = document.getElementById('joystick-zone');
                joy.addEventListener('pointerdown', e => {
                    e.stopPropagation(); joy.setPointerCapture(e.pointerId);
                    joy.onpointermove = ev => {
                        ev.stopPropagation();
                        const r = joy.getBoundingClientRect();
                        const dx = ev.clientX - (r.left+60), dy = ev.clientY - (r.top+60);
                        const d = Math.min(Math.sqrt(dx*dx+dy*dy), 40);
                        const a = Math.atan2(dy,dx);
                        const fx = Math.cos(a)*d, fy = Math.sin(a)*d;
                        document.getElementById('stick').style.transform=`translate(${fx}px,${fy}px)`;
                        Game.inputs.x = fx/40; Game.inputs.y = fy/40;
                    };
                    joy.onpointerup = () => { joy.onpointermove=null; document.getElementById('stick').style.transform='translate(0,0)'; Game.inputs={x:0,y:0}; };
                });

                document.getElementById('jump-btn').addEventListener('pointerdown', e => { e.stopPropagation(); Game.jump(); });
            }
        };
    </script>
</body>
</html>
